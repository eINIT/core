<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
               "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">

<book lang="en">
 <bookinfo>
  <date>2007-08-30</date>
  <title>eINIT 0.24.4: Documentation</title>
  <authorgroup>
   <author>
    <firstname>Magnus</firstname>
    <surname>Deininger</surname>
   </author>
  </authorgroup>
  <copyright>
   <year>2007</year>
   <holder>Magnus Deininger</holder>
  </copyright>
  <legalnotice>
   <para>(C) 2007 Magnus Deininger, All rights reserved.</para>
   <para>Redistribution and use in source and binary forms, with or without modification,
    are permitted provided that the following conditions are met:</para>
   <itemizedlist>
    <listitem><para>Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.</para></listitem>
    <listitem><para>Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.</para></listitem>
    <listitem><para>Neither the name of the project nor the names of its contributors may be
     used to endorse or promote products derived from this software without
     specific prior written permission.</para></listitem>
   </itemizedlist>
   <para>
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   </para>
  </legalnotice>
  <abstract>
   <para>This is an attempt at documenting eINIT as of version 0.24.4.</para>
   <para>This is currently a WIP ("Work in Progress"), but your feedback is greatly appreciated. If you'd like to
    point out flaws, shortcomings or ideas, please file an issue on einit.org, or join #einit on freenode. We're
    eager to hear from you. :)</para>
  </abstract>
 </bookinfo>

 <chapter id="introduction">
  <title>Introduction</title>

  <sect1 id="introduction-what-is-einit">
   <title>What is eINIT?</title>
   <titleabbrev>About</titleabbrev>

   <para></para>
  </sect1>

  <sect1 id="introduction-why-einit">
   <title>Why would I want to use eINIT?</title>
   <titleabbrev>Why</titleabbrev>

   <para></para>
  </sect1>
 </chapter>

 <chapter id="users">
  <title>User's Guide</title>

  <sect1 id="users-installation">
   <title>Installing eINIT</title>
   <titleabbrev>Installation</titleabbrev>

   <para></para>
  </sect1>

  <sect1 id="users-configuration">
   <title>Configuring eINIT</title>
   <titleabbrev>Configuration</titleabbrev>

   <para></para>

   <sect2 id="users-configuration-etc-einit">
    <title>The Configuration Files: /etc/einit</title>
    <titleabbrev>/etc/einit</titleabbrev>

    <para></para>

    <sect3 id="users-configuration-etc-einit-network-xml">
     <title>Network Configuration: /etc/einit/network.xml</title>
     <titleabbrev>/etc/einit/network.xml</titleabbrev>

     <para></para>
    </sect3>

    <sect3 id="users-configuration-etc-einit-modes-xml">
     <title>What Services to start: /etc/einit/modes.xml</title>
     <titleabbrev>/etc/einit/modes.xml</titleabbrev>

     <para></para>
    </sect3>

    <sect3 id="users-configuration-etc-einit-conf-d">
     <title>Service-Configuration: /etc/einit/conf.d</title>
     <titleabbrev>/etc/einit/conf.d</titleabbrev>

     <para></para>
    </sect3>

    <sect3 id="users-configuration-etc-einit-fstab-xml">
     <title>(Optional) Advanced fstab: /etc/einit/fstab.xml</title>
     <titleabbrev>/etc/einit/fstab.xml</titleabbrev>

     <para></para>
    </sect3>
   </sect2>
  </sect1>

  <sect1 id="users-using">
   <title>Using eINIT</title>
   <titleabbrev>Using</titleabbrev>

   <para></para>

   <sect2 id="users-using-einit-control">
    <title>The "einit-control"-Command: Have a chat with eINIT</title>
    <titleabbrev>einit-control</titleabbrev>

    <para></para>

    <sect3 id="users-using-erc">
     <title>The "erc"-Command: Manipulating Services' Status</title>
     <titleabbrev>erc</titleabbrev>

     <para></para>
    </sect3>

    <sect3 id="users-using-power">
     <title>The "power"-Command: Shutting Down and Rebooting</title>
     <titleabbrev>power</titleabbrev>

     <para></para>
    </sect3>
   </sect2>
  </sect1>
 </chapter>

 <chapter id="developers">
  <title>Developer's Guide</title>

  <sect1 id="developers-intro">
   <title>Introduction</title>
   <titleabbrev>Introduction</titleabbrev>

   <para>So eINIT lacks some feature you want, and you'd like to help us by writing it, eh? Excellent, so then this is
    exactly the spot to look at! This chapter covers all the details of the core that you need to know about to write
    your very own eINIT modules.</para>

   <sect2 id="developers-intro-writing-modules">
    <title>Writing Modules</title>
    <titleabbrev>Writing Modules</titleabbrev>

    <para>This is the most general thing: writing modules.</para>
   </sect2>

   <sect2 id="developers-intro-testing">
    <title>Testing Modules</title>
    <titleabbrev>Testing</titleabbrev>

    <para></para>
   </sect2>
  </sect1>

  <sect1 id="developers-writing-modules-c">
   <title>C Modules</title>
   <titleabbrev>C Modules</titleabbrev>

   <para>This is the "mother of all modules". It's eINIT's native module format, so to speak; as native as it gets,
    anyway (writing your code in C++ or pascal or anything like that is as native as C-Modules are, provided you stick
    to the right calling conventions and can generate either a .o file to link into eINIT or a .so file to load).</para>

   <para><xref linkend="developers-writing-modules-c-format" /> sums up the generic form of C modules. It all starts
    with a static module descriptor, which contains a reference entry for the dependencies, an RID, a name, some options
    and a pointer to a configure()-function.</para>

   <para>When the module is loaded, the core will call the configure()-function, and pass it the core's module-
    descriptor of itself, which can then be used to modify the list of functions and some other parameters of a
    module.</para>

   <figure id="developers-writing-modules-c-format" float="1" pgwide="0" floatstyle="right">
    <title>C-Module Format</title>
    <mediaobject>
     <textobject>
      <para>illustrate all this right here.</para>
     </textobject>
    </mediaobject>
   </figure>

   <sect2 id="developers-writing-modules-c-descriptors">
    <title>Module Descriptors</title>
    <titleabbrev>Descriptors</titleabbrev>

    <para><xref linkend="developers-writing-modules-c-descriptor-example" /> demonstrates how to write a module
     descriptor in C. Yes I know it's ugly, but you don't usually need to bother with thinking how it works, just copy
     that one verbatim and modify the my_module_ prefixes to fit your module, then adjust the settings in there.</para>

    <example id="developers-writing-modules-c-descriptor-example">
     <title>A typical module descriptor</title>
     <programlisting language="C"><![CDATA[#include <einit/module.h>

#define EXPECTED_EIV 1

#if EXPECTED_EIV != EINIT_VERSION
#warning "This module was developed for a different version of eINIT, you might experience problems"
#endif

int my_module_configure (struct lmodule *);

#if defined(EINIT_MODULE) || defined(EINIT_MODULE_HEADER)

char * my_module_provides[] = { "coolness", NULL };

const struct smodule my_module_self = {
 .eiversion = EINIT_VERSION,
 .eibuild   = BUILDNUMBER,
 .version   = 1,
 .mode      = einit_module_generic,
 .name      = "My Shiny New Module",
 .rid       = "module-mine",
 .si        = {
  .provides = my_module_provides,
  .requires = NULL,
  .after    = NULL,
  .before   = NULL
 },
 .configure = my_module_configure
};

module_register(my_module_self);

#endif]]></programlisting>
    </example>

    <para>The reason it looks so ugly is only that bit of preprocessor magic actually. The first #include is fairly
     obvious: you need to know how to do these structures, so that's why that one is needed. The #define EXPECTED_EIV
     is there to make it easier to adjust the next test, which checks said macro against EINIT_VERSION. This test is
     to ensure that you're compiling the module for an appropriate API version of eINIT, and to at least throw a
     #warning if there's a mismatch. After that there's your typical function declaration for my_module_configure(),
     which is generally a good idea, and so that you can write the code for that function later but already reference
     it now. The next preprocessor directive, that second #if, is used to find out if we're clear to define a module
     header at all. If we are, we're just defining a struct smodule (which needs to be constant, thus the 'const') and
     we initialise that using the rather convenient C99 way. After that we register this module descriptor as <emphasis>
     this module's descriptor</emphasis> using module_register(). That last bit is actually some preprocessor magic
     which makes sure the same module file works for both linking statically into the core and for linking as a .so
     module.</para>

    <para>Now you know. And also remember that you don't really need to bother with this, just copy it and modify it
     to suite your needs. ;)</para>
   </sect2>

   <sect2 id="developers-writing-modules-c-functions">
    <title>Module Functions</title>
    <titleabbrev>Functions</titleabbrev>

    <para>The main purpose of any module is <emphasis>doing something</emphasis>, and in C you do things in functions,
     so the first thing we'll do is explain all the functions a module can have that may get called by the core
     directly.</para>

    <sect3 id="developers-writing-modules-c-functions-configure">
     <title>configure()</title>
     <titleabbrev>configure()</titleabbrev>

     <para>This function is the main entry-point for your module. It gets run as soon as the module is registered to the
      core, and it gets a pointer to the core's descriptor so that the module can tell the core what it can do.</para>

     <example id="developers-writing-modules-c-functions-configure-definition">
      <title>A configure()-function in C</title>
      <programlisting language="C"><![CDATA[int my_module_configure (struct lmodule *me) {
 /* code */

 return 0;
}]]></programlisting>
     </example>

     <para>The configure-function's job is to initialise your module so that it can carry out all the actions you want
      it to carry out. Such initialisation includes - but is not limited to - setting up libraries that you linked in,
      setting the core-descriptor's function pointers, reading certain configuration entries or allocating chunks of
      memory to work with. Do note that the return value is pretty much ignored as of this version of eINIT. You can't
      really indicate that your module won't work and should thus be ignored, yet.</para>

     <para><xref linkend="developers-writing-modules-c-functions-configure-usage" /> shows a typical configure-function
      that sets some of the important pointers in the core-descriptor. That example would assume having enable()-,
      disable()- and cleanup()-functions in your module, of course.</para>

     <example id="developers-writing-modules-c-functions-configure-usage">
      <title>A configure()-function that initialises parts of the core-descriptor</title>
      <programlisting language="C"><![CDATA[int my_module_configure (struct lmodule *me) {
 me->enable = my_module_enable;
 me->disable = my_module_disable;

 me->cleanup = my_module_cleanup;

 return 0;
}]]></programlisting>
     </example>
    </sect3>

    <sect3 id="developers-writing-modules-c-functions-cleanup">
     <title>cleanup()</title>
     <titleabbrev>cleanup()</titleabbrev>

     <para>This function is called whenever a module needs to be unloaded or otherwise de-initialised. This is,
      admittedly, not done very often yet, but you should still make sure to provide such a function.</para>

     <example id="developers-writing-modules-c-functions-cleanup-definition">
      <title>A cleanup()-function in C that gets registered in the configure()-function</title>
      <programlisting language="C"><![CDATA[int my_module_cleanup (struct lmodule *me) {
 /* cleanup code here */

 return 0;
}

int my_module_configure (struct lmodule *me) {
 /* other initialisation code */

 me->cleanup = my_module_cleanup;

 /* other initialisation code */

 return 0;
}]]></programlisting>
     </example>

     <para>The cleanup-function's job is to deallocate data structures used by your module and to get rid of event-
      handlers and the like, so that after this module is done, the module may safely be unloaded. As with the
      configure-function, the return value is currently ignored.</para>

     <note><para>This function is more of a stub right now, since there are practically no occasions where a module is
      actually unloaded. This is expected to change soon, however, so you should write this function anyway.</para></note>

    </sect3>

    <sect3 id="developers-writing-modules-c-functions-enable">
     <title>enable()</title>
     <titleabbrev>enable()</titleabbrev>

     <para>This function is used to "enable" a service. It's only used in functions that provide a service.</para>

     <example id="developers-writing-modules-c-functions-enable-definition">
      <title>An enable()-function in C that gets registered in the configure()-function</title>
      <programlisting language="C"><![CDATA[int my_module_enable (void *param, struct einit_event *status) {
 /* code here */

 /* do something that may fail */

 if (things_worked_out) {
  return status_ok; /* return this way if your module succeeds */
 } else {
/* you can provide module-feedback like this: */
  fbprintf (status, "Could not enable module: %s", strerror (errno));

  return status_failed; /* return like this if your module screwed up... */
 }

 return status_ok; /* be good, assume it worked */
}

int my_module_configure (struct lmodule *me) {
 /* other initialisation code */

 me->enable = my_module_enable;
 me->param = NULL;

 /* other initialisation code */

 return 0;
}]]></programlisting>
     </example>

     <para>Enable-functions are very important, since a lot of the modules that need to be written will actually
      provide a service. In order to provide a service, there must be an enable()-function that arranges for the service
      to be provided, for example by starting a daemon, by running gettys, by spawning a thread that allows some form
      of interaction and so on.</para>

     <para>The return value of this type of function is very important: the return code "status_ok" means "all good,
      the service is now provided", whereas the return code "status_failed" means "no go, something's wrong". You'd
      use the former if you're at least reasonably sure things worked, and the latter if either you tried your thing
      and you know it failed, or if you can be sure it'll fail if you tried it (for example a daemon's binary or
      configuration data is missing, so running it would be pointless).</para>

     <para>Arguments to this functions are a (void *) and a (struct einit_event *) pointer. The former is the same
      pointer that is also in the core-descriptor's param-field (see
      <xref linkend="developers-writing-modules-c-functions-enable-definition" /> for how to set that), and the latter
      is a convenience for module authors that wish to provide feedback for their module's status. For example it's
      fairly easy to write module output with fbprintf(), as shown in
	  <xref linkend="developers-writing-modules-c-functions-enable-definition" />.</para>

     <note><para>Make sure you also understand about the whole thing of backup modules for services. Just because your
      module is providing some service doesn't necessarily mean it's the only candidate and it thus also doesn't mean
      that it'll be chosen to provide a service if it's requested. That also means that even if your module indicates
      failure, the service might still get provided eventually by some other module.</para></note>

    </sect3>

    <sect3 id="developers-writing-modules-c-functions-disable">
     <title>disable()</title>
     <titleabbrev>disable()</titleabbrev>

     <para>This function is used to "disable" a service. It's analogous to enable()-functions, it just does the exact
      opposite. Even the parameters and expected return-values are the same.</para>

     <example id="developers-writing-modules-c-functions-disable-definition">
      <title>A disable()-function in C that gets registered in the configure()-function</title>
      <programlisting language="C"><![CDATA[int my_module_disable (void *param, struct einit_event *status) {
 /* code here */

 /* do something that may fail */

 if (things_worked_out) {
  return status_ok; /* return this way if your module succeeds */
 } else {
/* you can provide module-feedback like this: */
  fbprintf (status, "Could not disable module: %s", strerror (errno));

  return status_failed; /* return like this if your module screwed up... */
 }

 return status_ok; /* be good, assume it worked */
}

int my_module_configure (struct lmodule *me) {
 /* other initialisation code */

 me->disable = my_module_disable;
 me->param = NULL;

 /* other initialisation code */

 return 0;
}]]></programlisting>
     </example>

     <para>All the notes that apply to an enable-function apply to disable-functions as well. There is only one
      important difference: if your disable-function for a service fails, and the system is shutting down, then your
      module will get "zapped". This is done without even informing you, so you really should make sure to clean up
      properly.</para>

     <note><para>Disable functions will only ever be called for modules that are actually enabled in the first place.
      This should be kind of obvious, but it may be good to know when it comes to services that have multiple modules
      to provide it.</para></note>
    </sect3>

    <sect3 id="developers-writing-modules-c-functions-scanmodules">
     <title>scanmodules()</title>
     <titleabbrev>scanmodules()</titleabbrev>

     <para>This function gets called by the core whenever your module is supposed to give the core a list of modules.
      Obviously, this only makes sense for module-loaders. Unless you're writing a specialised .so module loader, this
      function will also need to generate a static module-descriptor and maybe substitute wrapper functions for your
      new module's functionality.</para>

     <example id="developers-writing-modules-c-functions-scanmodules-definition">
      <title>A scanmodules()-function in C that gets registered in the configure()-function</title>
      <programlisting language="C"><![CDATA[int my_module_scanmodules (struct lmodule *modules) {
 /* scanmodules code here */

 return 0;
}

int my_module_configure (struct lmodule *me) {
 /* other initialisation code */

 me->scanmodules = my_module_scanmodules;

 /* other initialisation code */

 return 0;
}]]></programlisting>
     </example>

     <para>This module is supposed to get a list of modules off an applicable source and to register those modules with
      the core using the core's mod_add() function, or to update the module's data that the core has and to tell the
      core about such an update.</para>

     <note><para>This function will only ever be called if your module's static descriptor has the option
      'einit_module_loader' in its mode-field.</para></note>

    </sect3>
   </sect2>

   <sect2 id="developers-writing-modules-c-events">
    <title>Using Events</title>
    <titleabbrev>Events</titleabbrev>

    <para></para>

    <sect3 id="developers-writing-modules-c-events-handlers">
     <title>Event Handlers</title>
     <titleabbrev>Handlers</titleabbrev>

     <para><xref linkend="developers-writing-modules-c-events-handlers-example"/> shows a definition for a typical
      event-handler. Those handlers return void and get exactly one argument, a (struct einit_event *).</para>

     <example id="developers-writing-modules-c-events-handlers-example">
      <title>An Event-Handler</title>
      <programlisting language="C"><![CDATA[void my_module_core_event_handler (struct einit_event *ev) {
 /* event handler code */
}]]></programlisting>
     </example>

     <para>To get these event-handlers called, you need to use event_listen(); to stop them from being called, you'd use
      event_ignore(), like in <xref linkend="developers-writing-modules-c-events-handlers-registering" />. In that
      example my_module_core_event_handler() is registered to listen for anything that has the subsystem id of
      'einit_event_subsystem_core', then some stuff is done and at the end of the function, einit is told to ignore any
      events from then on.</para>

     <para>That example is fairly synthetic, however, since normally you'd rather register such an event-handler in
      either the configure()-function or the enable()-function, and you tell einit to ignore it again in the
      cleanup()-function or the disable()-function.</para>

     <example id="developers-writing-modules-c-events-handlers-registering">
      <title>Registering an Event-Handler</title>
      <programlisting language="C"><![CDATA[void somefunction () {
/* ... some code ... */

/* register event handler */
 event_listen (einit_event_subsystem_core, my_module_core_event_handler);

/* ... some more code ... */

/* de-register event handler */
 event_ignore (einit_event_subsystem_core, my_module_core_event_handler);

/* ... yet more code ... */

 return;
}]]></programlisting>
     </example>

    </sect3>
   </sect2>

   <sect2 id="developers-writing-modules-c-templates">
    <title>Small Module Templates</title>
    <titleabbrev>Template</titleabbrev>

    <para>To help you get started, I've written a couple of module templates for you to use. They're obviously not
     doing much, but they should get you started and hacking in no time.</para>

    <sect3 id="developers-writing-modules-c-templates-service">
     <title>Template for a service-providing Module</title>
     <titleabbrev>Regular Module Template</titleabbrev>

     <para>These are easy, just make sure you have enable() and disable()-functions and don't forget to fill out that
      .provides pointer.</para>

     <example id="developers-writing-modules-c-service-template">
      <title>A Blank Service-Providing Module</title>
      <programlisting language="C"><![CDATA[/*
 *  my-module.c
 *  einit
 *
 *  Created on DD/MM/YYYY.
 *  Copyright 2007 Me - myself - Mineson. All rights reserved.
 *
 */

/*
 LONG LEGAL MUMBO JUMBO APPROPRIATE TO MODULE'S LICENSE
*/

#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <string.h>
#include <einit/module.h>
#include <einit/config.h>
#include <einit/bitch.h>
#include <einit/utility.h>
#include <errno.h>

#define EXPECTED_EIV 1

#if EXPECTED_EIV != EINIT_VERSION
#warning "This module was developed for a different version of eINIT, you might experience problems"
#endif

int my_module_configure (struct lmodule *);

#if defined(EINIT_MODULE) || defined(EINIT_MODULE_HEADER)

char * my_module_provides[] = {"my-service", NULL};
char * my_module_requires[] = {"mount-system", NULL};
  /* the .requires attribute is optional... */
char * my_module_after[]    = {"^(fqdn|net-lo)$", NULL};
  /* ... as is the .after one... */
char * my_module_before[]   = {"^displaymanager$", NULL};
  /* ... and the .before attribute */

/* remember that .after and .before don't specify a set of service names but a
   set of regular expressions that are supposed to match service names. */

const struct smodule my_module_self = {
 .eiversion = EINIT_VERSION,
 .eibuild   = BUILDNUMBER,
 .version   = 1,
 .mode      = einit_module_generic,
 .name      = "My Modules' Verbose Name",
 .rid       = "my-module",
 .si        = {
  .provides = my_module_provides,
  .requires = my_module_requires,
  .after    = my_module_after,
  .before   = my_module_before
 },
 .configure = my_module_configure
};

module_register(my_module_self);

#endif

int my_module_enable  (void *, struct einit_event *);
int my_module_disable (void *, struct einit_event *);

int my_module_cleanup (struct lmodule *pa) {
/* cleanup code here */

 return 0;
}

int my_module_enable (void *param, struct einit_event *status) {
 /* code here */

 /* do something that may fail */

 if (things_worked_out) {
  return status_ok; /* return this way if your module succeeds */
 } else {
/* you can provide module-feedback like this: */
  fbprintf (status, "Could not enable module: %s", strerror (errno));

  return status_failed; /* return like this if your module screwed up... */
 }

 return status_ok; /* be good, assume it worked */
}

int my_module_disable (void *param, struct einit_event *status) {
 /* code here */

 /* do something that may fail */

 if (things_worked_out) {
  return status_ok; /* return this way if your module succeeds */
 } else {
/* you can provide module-feedback like this: */
  fbprintf (status, "Could not disable module: %s", strerror (errno));

  return status_failed; /* return like this if your module screwed up... */
 }

 return status_ok; /* be good, assume it worked */
}

int my_module_configure (struct lmodule *pa) {
 module_init (pa);

 pa->enable = my_module_enable;
 pa->disable = my_module_disable; /* yes, ->disable is required! */
 pa->cleanup = my_module_cleanup;

/* more configure code here */

 return 0;
}]]></programlisting>
     </example>
    </sect3>

    <sect3 id="developers-writing-modules-c-templates-passive">
     <title>Template for a passive Module</title>
     <titleabbrev>Passive Module Template</titleabbrev>

     <para>Passive modules tend to not have enable/disable functions, but instead only grab events and register
      functions for other modules to use.</para>

     <example id="developers-writing-modules-c-passive-template">
      <title>A Blank Passive Module, which registers two Event Handlers and one Registered Function</title>
      <programlisting language="C"><![CDATA[/*
 *  my-module.c
 *  einit
 *
 *  Created on DD/MM/YYYY.
 *  Copyright 2007 Me - myself - Mineson. All rights reserved.
 *
 */

/*
 LONG LEGAL MUMBO JUMBO APPROPRIATE TO MODULE'S LICENSE
*/

#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <string.h>
#include <einit/module.h>
#include <einit/config.h>
#include <einit/bitch.h>
#include <einit/utility.h>
#include <errno.h>

#define EXPECTED_EIV 1

#if EXPECTED_EIV != EINIT_VERSION
#warning "This module was developed for a different version of eINIT, you might experience problems"
#endif

int my_module_configure (struct lmodule *);

#if defined(EINIT_MODULE) || defined(EINIT_MODULE_HEADER)

const struct smodule my_module_self = {
 .eiversion = EINIT_VERSION,
 .eibuild   = BUILDNUMBER,
 .version   = 1,
 .mode      = einit_module_generic,
 .name      = "My Modules' Verbose Name",
 .rid       = "my-module",
 .si        = {
  .provides = NULL,
  .requires = NULL,
  .after    = NULL,
  .before   = NULL
 },
 .configure = my_module_configure
};

module_register(my_module_self);

#endif

void my_module_core_event_handler (struct einit_event *ev) {
 switch (ev->type) {
  case einit_core_configuration_update:
   /* some code */
   break;

  default:
   /* default: is necessary to make sure the compiler won't warn us of
      unhandled events. */
   break;
 }
}

void my_module_ipc_event_handler (struct einit_event *ev) {
 /* mess with ev->argv here */
}

void *my_module_some_function (void *arg1, int arg2, char **arg3) {
 /* do whatever your function is supposed to do */

 /* do note that it's YOUR JOB to make sure the arguments in your function
    match up with the arguments that the callees think your function will have.
    neither eINIT nor GCC will complain if there's a mismatch! */
}

int my_module_cleanup (struct lmodule *pa) {
 /* cleanup code here */

 function_unregister ("my-fancy-new-function", 1, my_module_some_function);

 event_ignore (einit_event_subsystem_ipc, my_module_ipc_event_handler);
 event_ignore (einit_event_subsystem_core, my_module_core_event_handler);

 return 0;
}

int my_module_configure (struct lmodule *pa) {
 module_init (pa);

 pa->cleanup = my_module_cleanup;

 event_listen (einit_event_subsystem_core, my_module_core_event_handler);
 event_listen (einit_event_subsystem_ipc, my_module_ipc_event_handler);

 function_register ("my-fancy-new-function", 1, my_module_some_function);

 /* more configure code here */

 return 0;
}]]></programlisting>
     </example></sect3>

    <sect3 id="developers-writing-modules-c-templates-loader">
     <title>Template for a Module-Loader</title>
     <titleabbrev>Module-Loader Template</titleabbrev>

     <para>Module-loaders can be a bit intriguing, but there's not much magic behind them. Remember to use mod_add()
      and mod_update() and that the .mode = einit_module_loader isn't just for cosmetics. :)</para>

     <example id="developers-writing-modules-c-loader-template">
      <title>A Blank Module-Loader Module</title>
      <programlisting language="C"><![CDATA[/*
 *  my-module.c
 *  einit
 *
 *  Created on DD/MM/YYYY.
 *  Copyright 2007 Me - myself - Mineson. All rights reserved.
 *
 */

/*
 LONG LEGAL MUMBO JUMBO APPROPRIATE TO MODULE'S LICENSE
*/

#include <stdlib.h>
#include <stdio.h>
#include <sys/types.h>
#include <string.h>
#include <einit/module.h>
#include <einit/config.h>
#include <einit/bitch.h>
#include <einit/utility.h>
#include <errno.h>

#define EXPECTED_EIV 1

#if EXPECTED_EIV != EINIT_VERSION
#warning "This module was developed for a different version of eINIT, you might experience problems"
#endif

int my_module_configure (struct lmodule *);

#if defined(EINIT_MODULE) || defined(EINIT_MODULE_HEADER)

const struct smodule my_module_self = {
 .eiversion = EINIT_VERSION,
 .eibuild   = BUILDNUMBER,
 .version   = 1,
 .mode      = einit_module_loader,
 .name      = "Module Support (My Modules)",
 .rid       = "my-module",
 .si        = {
  .provides = NULL,
  .requires = NULL,
  .after    = NULL,
  .before   = NULL
 },
 .configure = my_module_configure
};

module_register(my_module_self);

#endif

int my_module_scanmodules (struct lmodule *);

int my_module_cleanup (struct lmodule *pa) {
/* cleanup code here */

 return 0;
}

int my_module_scanmodules (struct lmodule *modchain) {
/* You need to get your modules from somewhere, see if they're there, if so invoke mod_update() on them,
   and if not invoke mod_add() to get them onto the list. */

 while (modchain) {
  if (modchain->module && modchain->module->rid && see_if_my_module_knows_rid (modchain->module->rid)) {
/* modify the module if necessary */

   mod_update (modchain);
   remember_that_we_did_stuff_for_this_rid (modchain->module->rid);
  }

  modchain = modchain->next;
 }

 add_all_new_modules_using_mod_add ();

/* Note that the pseudocode above suggests using the rids of modules to remember your own modules.
   There's also  other ways to do this, like using a set to store their (struct lmodule *) pointers,
   or using the source field. It's all up to you, really. */

/* remember to construct a (struct smodule *) if necessary */

 return 1;
}

int my_module_configure (struct lmodule *pa) {
 module_init (pa);

 pa->scanmodules = my_module_scanmodules;
 pa->cleanup = my_module_cleanup;

/* more configure code here */

 return 0;
}
]]></programlisting>
     </example>
    </sect3>

    <sect3 id="developers-writing-modules-c-templates-shadow">
     <title>Template for a Shadow Module</title>
     <titleabbrev>Shadow Module Template</titleabbrev>

     <para></para>
    </sect3>
   </sect2>
  </sect1>

  <sect1 id="developers-writing-modules-xml">
   <title>XML/SH Modules</title>
   <titleabbrev>XML</titleabbrev>

   <para>XML modules are more-or-less bindings to run commands through sh. They only offer a small subset of the
    C-Modules' functionality, but usually it's adequate. From a technical point of view, these modules should rather
    be called "Configuration Modules", since the governing module-loader doesn't care if the configuration-data it
    uses to genereate these modules actually comes from an XML file or not.</para>

   <sect2 id="developers-writing-modules-xml-drawbacks">
    <title>Things you can't do with XML/SH modules</title>
    <titleabbrev>XML/SH Drawbacks</titleabbrev>

    <para></para>
   </sect2>
  </sect1>

  <sect1 id="developers-writing-modules-scheme">
   <title>Scheme Modules</title>
   <titleabbrev>Scheme Modules</titleabbrev>

   <para>At the time of this writing, Scheme modules are not fully implemented yet. We've got an additional developer
    working on this, or at least looking into it, so it shouldn't be long before these can be used properly.</para>
   <para>Even so, some things can already be done a lot better in Scheme modules than in C or XML modules, most notably
    everything related to manipulating eINIT variables/configuration data.</para>

   <sect2 id="developers-writing-modules-scheme-drawbacks">
    <title>Things you can't do with Scheme modules</title>
    <titleabbrev>Scheme Drawbacks</titleabbrev>

    <para></para>
   </sect2>
  </sect1>

  <sect1 id="developers-sandbox">
   <title>Testing Code: Sandbox-Mode</title>
   <titleabbrev>Sandbox Mode</titleabbrev>

   <para></para>
  </sect1>

  <sect1 id="developers-submitting-modules">
   <title>Submitting Modules</title>
   <titleabbrev>Submitting</titleabbrev>

   <para>If you wish to submit any modules you write, you're very much encouraged to do so. Submissions through #einit
    on freenode would probably be best, but if you don't want to do that then there's always einit.org's issue tracker,
    various threads on fgo or you could mail us. Your submission will of course also lead to you being mentioned in
    the contributors section.</para>

   <sect2 id="developers-submitting-modules-license">
    <title>License and License Issues</title>
    <titleabbrev>License</titleabbrev>

    <para>One thing first: I personally don't really care what license you'd want to place your modules under. Really,
     I don't care. Ideally it'd be a BSD-style license, of course, but which license you choose is your thing. Now,
     As you've probably noticed, the core is under a BSD-style license. That means that in order to get your submissions
     into the actual core-distribution, you need to put your code under a BSD-compatible license. There's a lot of
     those, but unfortunately the GNU GPL is not one of them.</para>

    <para>Now, I have nothing against the GNU GPL in and of itself, but unfortunately if I bundled GPL'd code with BSD'd
     code, then the GPL'd code would probably override the BSD license, which means that all GPL'd code will have to be
     bundled in a separate package. Users would probably not even notice anything of this, however, since most package
     managers should be able to merge this stuff together before installing, but the core tarball won't be able to
     include code that is under a license which is not compatible with the BSD license. I'm sorry, but I can't change
     the license details :/. (Just google for the issue if you want details.)</para>
   </sect2>
  </sect1>
 </chapter>

 <appendix id="concepts">
  <title>Terms and Concepts</title>
  <sect1 id="concepts-modules">
   <title>Modules</title>
   <titleabbrev>Modules</titleabbrev>
   <para>Modules are the "building blocks" for eINIT. They can be a lot of things, ranging from simple
    "start-this-program-when-you're-called" modules to more complex "store-and-retrieve-configuration-data" ones
	or even more complex managers that determine the order in which modules are started or that tackle
	the whole issue of mounting things while booting.</para>

   <para>Since modules are pretty much everything, some people will long for a way to categorise them,
    (even though this is blatantly contradictory to everything tought in books like Lao Tse's "Tao Te King").</para>

   <para><xref linkend="concepts-modules-core-interaction" /> illustrates the interaction between the core
    and the modules. All the modules (middle column) are loaded by a module loader (left column). This loading
    is requested by the core itself, when it invokes the scanmodules()-function of the module loader. The
    "code"-section spans both the module loader and the module itself, because many types of modules require
    wrapper-code from the module-loader to function as intended (e.g. XML-Modules need a wrapper like this,
    since XML is definitely not compiled object code, and thus the core cannot execute functions of these
    modules directly).</para>

   <para>As indicated in the figure, there's two kinds of descriptors around for every eINIT module: one "static
    descriptor", and another one called the "core descriptor" (the figure has two static descriptors, because
	the module loader to the left is just a module too, albeit one with a scanmodules()-function). The reason
    for two descriptors is simple, the static one acts as a reference entry (especially for the dependencies),
	and the core descriptor lists the "current" data and some function pointers as shortcuts. See the guide on
	C-Modules for details on what function pointers need to be provided. Additionally, the core descriptor keeps
	track of a module's "status", that is, whether it's enabled, disabled, broken, etc...</para>

   <figure id="concepts-modules-core-interaction" float="1" pgwide="0" floatstyle="right">
    <title>Modules, Module Loaders and the Core</title>
    <mediaobject>
     <imageobject>
      <imagedata fileref="images/module.svg" format="SVG" />
     </imageobject>
     <imageobject>
      <imagedata fileref="images/module.png" format="PNG" />
     </imageobject>
    </mediaobject>
   </figure>

   <note><para>Remember that none of these names are normative or absolute. They're not mutually exclusive either,
    they're just here to help you get started.</para></note>

   <para>One thing that all these modules have in common, is that there absolutely <emphasis>must</emphasis> be an
    "RID" (the unique identifier for a module) and a name for each and every one of them.</para>

   <para>Now that you've gotten a little heads-up on modules, let's get a wee bit dirty with them, shall we?</para>

   <sect2 id="concepts-modules-service">
    <title>Modules that provide Services</title>
    <titleabbrev>Regular Modules</titleabbrev>

    <para>This is the easy type of modules. Anything that has something in the "provides"-field of its dependency-
	 descriptor falls in this category. A lot of these modules are XML-modules, simply because a lot of services
     aren't provided by einit itself, but some other program, which needs to be executed. XML modules were designed
     for this task. Examples for such modules are the whole series of "displaymanager-modules", such as daemon-kdm
	 and daemon-gdm, logger/syslog modules like daemon-metalog, or plain ol' apache and gpm.</para>

    <para>That's not to say that there weren't any C-Modules dealing with this. Some things provide these services,
     but they don't just "simply" start a daemon. Examples for this are the "tty" and "ipc" services: the tty-module
     provides you with gettys on your virtual terminals ((ctrl+)alt+f1 to (ctrl+)alt-f6), and makes sure the started
     gettys will respawn, should they die (because maybe someone logged in and then back out). The "ipc"-service,
	 on the other hand, is responsible for getting all the external programs to work that interact with eINIT:
	 einit-control, erc, power, etc.</para>

    <para>Logics dictate that since this type of module provides something, it also needs enable()- and disable()-
     functions, which are described in the Developer's Guide.</para>

    <para>In essence, this is any type of module that is most likely optional, provides a service and which will
     usually participate in global depedency resolution.</para>
   </sect2>
   <sect2 id="concepts-modules-loaders">
    <title>Modules that provide Modules ("Module Loaders")</title>
    <titleabbrev>Module Loaders</titleabbrev>

    <para>This is part of the magic that makes everything tick. These modules are usually passive (or mostly
     passive), since the scanmodules()-function (which should at least be part of their primary function) is out
     of dependency resolution's scope entirely.</para>

    <para>Examples for this module type are module-so, module-xml, module-scheme and distro-gentoo (not module-c,
     however). As is demonstrated by the distro-gentoo module, this type of module is not limited to providing
     other modules, but other functions are often appropriate there as well. In distro-gentoo, there is also
     "glue code", which makes gentoo-baselayout modules aware of dependencies that are already fulfilled, so
     that they won't try to bring up dependencies by themselves.</para>

    <para>Obviously, this type of module is a good starting point for any form of compatibility module, for example
     for distro-specific sysv-initscripts, or other alternative init systems. It's conceivable that one might write
     complete compatibility modules for InitNG, Upstart, Launchd and the like.</para>

    <para>Requirements for this type of module are at least a scanmodules()-function.</para>
   </sect2>
   <sect2 id="concepts-modules-passive">
    <title>Passive Modules</title>
    <titleabbrev>Passive Modules</titleabbrev>

    <para>"Passive" modules are modules that do whatever they're supposed to do with the user knowing little
     or nothing of their existance. Most of them have no use for enable()- and disable()-functions.</para>

    <para>Examples include the compat module for initctl (which makes sysv shutdown/reboot/halt commands work),
     and various parts of the mounter and process manipulation code, as well as the modules that deal with reading,
     storing and retrieving configuration data. (yes, those are modules as well, they're not hardcoded in any way).
     Most "module loaders" are passive modules as well.</para>
   </sect2>
   <sect2 id="concepts-modules-shadows">
    <title>Shadow Modules</title>
    <titleabbrev>Shadows</titleabbrev>

    <para>This is what Ryan dubbed a type of module that can execute things "around" other modules, for example
     when they're enabled and disabled. There's an interface for writing this type of module with XML, and after
     that they need to be specifically enabled. This is mostly intended for "hotfixes", along with dependency
     overrides.</para>

    <para>Another example of this are the initctl and logger-modules, which get automatically enabled along with
     appropriate mountpoints.</para>
   </sect2>
   <sect2 id="concepts-modules-core">
    <title>Modules that provide Core Functionality</title>
    <titleabbrev>Core Modules</titleabbrev>

    <para>This describes all modules that provide essential core functionality, like the whole configuration data
     parsing, or the module for dependency resolution.</para>
   </sect2>
  </sect1>

  <sect1 id="concepts-variables">
   <title>Variables / Configuration Data</title>
   <titleabbrev>Variables</titleabbrev>

   <para>All configuration from all sources is merged together by eINIT into a single big lookup table. Since all
    the entries in this table tend to have name/value pairs, they're dubbed "variables". Variables are name/value
    pairs themselves, so in eINIT you could think of the whole configuration thing as one big associative array of
    of associative arrays. With the difference that in the primary array keys may occur more than once.</para>

   <sect2 id="concepts-variables-xml">
    <title>What is the 'native' Configuration Format? It's XML, right?</title>
    <titleabbrev>Native Configuration</titleabbrev>

    <para>Nope, XML is not the native format of eINIT configuration data. The native format is an associative array
     (that allows colliding keys) that maps strings to associative arrays (which in turn does not allow colloding
     keys). The latter array maps strings to strings.</para>

    <para><xref linkend="concepts-variables-format" /> should illustrate this. Actually, we're just misusing XML as
     a pretty clear carrier for our data. I guess a lot of people would want to kill me for the ways I'm using XML
     data. For one thing, I'm not using the whole concept of "element values" at all, because it's somewhat awkward
     for eINIT's native data format, but on the other hand it's pretty much essential to XML, since it is actually
     supposed to be a markup language for... well, those same element values. I just know I'm going to get flames
     from both XML proponents and opponents alike.</para>

    <figure id="concepts-variables-format" float="1" pgwide="0" floatstyle="right">
     <title>'native' eINIT Configuration Data Format</title>
     <mediaobject>
      <textobject>
       <para>illustrate all this right here.</para>
      </textobject>
     </mediaobject>
    </figure>
   </sect2>
   <sect2 id="concepts-variables-xml-why">
    <title>Why does eINIT use XML by default?</title>
    <titleabbrev>Why XML?</titleabbrev>

    <para>Mostly because XML is easy to parse and quite well defined. Seriously, pretty much any language has at
     least one parser library for XML data, including most scripting languages (with the possible exception of
     sh/bash, but to be honest, I wouldn't be suprised if there really was a parser library for xml in sh).</para>

    <para>"Easy to parse" as in "easy to parse for a machine", because there's very few rules to implement, and
     they're well-defined with little ambiguity. "Easy to parse" also applies to humans, however. Yeah I know,
     people despise editing XML files by hand, but at least it's possible, isn't it? Better than being stuck with
     a binary format and needing to resort to arcane tools that hopefully work to get the job done. No automated
     text processing macros either... that'd suck. Especially if you somehow messed the data up and then somehow
     the tools would stop working. That'd be great, wouldn't it? Well, luckily XML is hand-editable with any
     common text editor, and the formatting rules are dead-simple.</para>

    <para>Additionally, Eliminating the need for my own parser library obviously has the advantage of making sure
     I can't screw one up myself, thus eliminating a whole class of nasty potential errors as well.</para>
   </sect2>
  </sect1>
  <sect1 id="concepts-dependencies">
   <title>Dependencies</title>
   <titleabbrev>Dependencies</titleabbrev>

   <para>Dependencies are intended for service-providing modules. They express what a module needs, what it works
    with and when it should start.</para>

   <para>Right now there are four majour types of dependencies: the "provides"- and then "requires"-dependencies,
    and the "before"- and "after"-dependencies. <xref linkend="concepts-dependencies-explained" /> should serve as
    a quick sum-up of the possible dependency-types.</para>

   <para>What a module "provides" isn't actually a dependency per-se, but it's what other modules can "require",
    so it's explained here. By telling eINIT and the user what it provides, a module can express abstract services
    to the user. For example the apache module would provide an "httpd" service, while gdm and kdm modules would
    provide a "displaymanager". Note how they don't explicitly provide apache or gdm/kdm: they provide what they do
    <emphasis>in general</emphasis>, not their exact implementation of that general thing.</para>

   <para>"Requirements" are a set of things that a module really needs. For example the music player daemon will
    always need one sound system or another, and network daemons will inevitably need some form of networking
    available to them. Things that a module "requires" must be aforementioned abstract service names. If one of the
    requirements can't be fulfilled, then a module that requires them is considered "broken", and it will not be
    started.</para>

   <para>"Before"- and "after"-dependencies can be used to hint eINIT about the order in which things should start.
    These dependencies are not expressed as service names, but instead they're regular expressions that match against
    service names that would be started alongside a module.</para>

   <figure id="concepts-dependencies-explained" float="1" pgwide="0" floatstyle="right">
    <title>eINIT Dependencies</title>
    <mediaobject>
     <textobject>
      <para>illustrate all this right here.</para>
     </textobject>
    </mediaobject>
   </figure>

   <sect2 id="concepts-dependencies-overrides">
    <title>Dependency Overrides</title>
    <titleabbrev>Overrides</titleabbrev>

    <para>Dependencies can be overriden in configuration files. Actually they can even have complex manipulations
     applied to them, which is intended to be used by module loaders that provide compatibility to alternative init
     systems or sysv distribution data. Doing this is called a "dependency override". The User's Guide should have
     more data on this.</para>
   </sect2>
  </sect1>
  <sect1 id="concepts-services">
   <title>Services</title>
   <titleabbrev>Services</titleabbrev>

   <para>A "service" is an abstract name for something that is done by a module. "Abstract" as in <emphasis>the
    general thing</emphasis>. That means that, for example, the service provided by all of gdm, xdm, kdm and
    entranced is "displaymanager", and not their respective service names.</para>

   <para>Now, why would we want to do that? It's fairly simple, really. The advantage is that using this method
    we can easily arrange for "backups" (see <xref linkend="concepts-services-backups" />). This has the handy
    side-effect of allowing us some degree of auto-detection.</para>

   <para>The other advantage is that modules don't need to be hard-coded to work for every possible combination
    of daemons that all essentially provide the same thing. A lot of services, for example, will require (or at
    least use) some form of syslog daemon. If we required specific syslog daemons, then things would get nasty
    fairly soon, since we'd need to write different editions of that one same module for all the different types
    of system loggers. Then when a new one comes around, we'd have to write new modules for all syslog-users.
    That's not very practical.</para>

   <para>The idea isn't entirely new either, while a lot of other systems provide very specific service names, most
    of them also seem to use "virtual" service-names for special services (especially syslog/syslog-ng/metalog,
    which get grouped together as "syslog" or "logger"). eINIT is just taking it a little farther by making this
    the native form right away.</para>

   <figure id="concepts-services-explained" float="1" pgwide="0" floatstyle="right">
    <title>eINIT Services: The Big Picture</title>
    <mediaobject>
     <textobject>
      <para>illustrate all this right here.</para>
     </textobject>
    </mediaobject>
   </figure>

   <sect2 id="concepts-services-backups">
    <title>Backup-Modules</title>
    <titleabbrev>Backups</titleabbrev>

    <para>One of the advantages of this abstraction is that eINIT has a list of possible modules to choose from for
     some modules. As in last chapter's example, if eINIT can't bring up metalog (maybe because it's broken, or
     because it's not even installed), it can try to bring up alternatives that still do the same thing: syslog-ng,
     for example.</para>

    <para>A more practical example would be a webserver. If, for some reason (broken config, we don't know how it
     happened), Apache cannot start, and there's a module providing the same service, maybe tinyhttpd, then eINIT
     would try to fall back to the latter. This could be used to provide a simpler service to users while apache is
     under maintenance, or to at least provide a warning message ("This server is currently down for scheduled
     maintenance. This is normal, our Tech Department did not screw up!"). Something like that could be beneficial,
     since instead of an annoying timeout, followed by a "page cannot be displayed"-warning from the browser, which
     looks rather unprofessional, any user would instead see a (possibly fancy-looking) "maintenance notice", which
     at least looks somewhat more professional, and should result in less people calling in.</para>

    <para>Using and relying on backup services will almost always also rely on preferring services, see
     <xref linkend="concepts-services-preferences" /> for more on this.</para>
   </sect2>
   <sect2 id="concepts-services-rid-vs-service">
    <title>Module-IDs v.s. Service Names</title>
    <titleabbrev>RID vs Services</titleabbrev>

    <para>This distinction may be a bit unclear to some. The Module-ID, or "RID", is that long name a module has,
     usually prefixed with the subsystem name (for example daemon-gdm or gentoo-acpid). The Service Name is that
     shorter one that can refer to more than one specific module, like with all the displaymanagers. You can't
     have a module-id as any form of dependency, other than specifying it in a mode to enable or disable it.</para>

    <para>Conversely, you can't specify an RID as something that a module provides, since then the RID wouldn't
     be unique anymore, and you'd instead be specifying a service name.</para>

    <para>Don't mix these two up. When it says RID, don't place service names in there, and if it says service names,
     don't use an RID!</para>
   </sect2>
   <sect2 id="concepts-services-preferences">
    <title>"Preferring" Modules for Services</title>
    <titleabbrev>Service-Preferences</titleabbrev>

    <para>Preferring services is quite straightforward, and works in the way described in
     <xref linkend="concepts-services-explained" />. Unless something is preferred, the order in which modules are
     attempted to be enabled for any given service is essentially random. However, with preferences you can specify
     the order in which things are attempted. Usually, you will only prefer one service, maybe two, and then don't
     really care about the remaining modules.</para>

    <para>There's three ways of specifying these preferences: Directly, by using "prefer-lines" (see the User's
     Guide) used to be the primary one, but maybe you shouldn't use it that much anymore, since it's harder to dig.
	 The other two ways are indirect. They work by specifying either an "unambiguous" additional service
     provided by a module, or by specifying a module's RID as a service name, along with the service name (in the
     same mode, for example). All of this should be explained well in
     <xref linkend="concepts-services-preferences-explained" />.</para>

    <figure id="concepts-services-preferences-explained" float="1" pgwide="0" floatstyle="right">
     <title>eINIT Services and Service Preferences</title>
     <mediaobject>
      <textobject>
       <para>illustrate all this right here.</para>
      </textobject>
     </mediaobject>
    </figure>

    <para>So, to be clear about which displaymanager to start, for example "GDM", in your mode you would put
     <emphasis>both</emphasis> "displaymanager", being the abstract service to start, and "daemon-gdm", which is
     the RID, a.k.a. the unique module-ID, for the gdm daemon. (this is the second indirect method, and usually the
     easiest one as well).</para>
   </sect2>
  </sect1>
  <sect1 id="concepts-groups">
   <title>Service Groups</title>
   <titleabbrev>Service Groups</titleabbrev>

   <para>Service groups are collections of other services under a common name. An example here is the "network"
    group, which is used to sum up all the network interfaces that should start automatically (like net-eth0).</para>

   <para>These groups will usually have members (in XML that's what's in the group= attribute) and a "sequence
    identifier" (seq=). The latter is either of "any", "any-iop", "most" and "all", which determines how many
    members of the group need to be enabled for the group to be considered "up", or "enabled".</para>

   <para>"All" means that unless every single one of the services is enabled, the group is not. "Most" means that
    eINIT will try to bring up everything, but in general the group is considered good if one of them ran fine.
	"Any" means just that: any of the services OK means the group is as well. For these groups eINIT will try to
    only bring one member up, unless one of them is already up. "Any-iop" means "any, in order of preference", which
    tells eINIT that it really should try to start any of the members of the group, but the order you specified is
    the order you expect eINIT to try the services in, until one succeeds.</para>

   <note><para>As of version 0.24.3, there is no difference between seq="any" and seq="any-iop" in groups, but this
    is intended to change with a future release, effectively making seq="any" always try the service that needs the
    least changes to get up.</para></note>

   <para>See the User's Guide for more details on specifying service groups.</para>
  </sect1>
  <sect1 id="concepts-modes">
   <title>Modes</title>
   <titleabbrev>Modes</titleabbrev>

   <para>A "mode" is what is used to tell eINIT what to start at boot-time, among other things.</para>

   <para>Modes are related to runlevels. In their easiest form, they're just named runlevels, but they can also
    contain other special attributes, inherit other runlevels' data and have their own variables that come with them
    and which are only valid in that specific mode. Especially the latter is an important difference to a runlevel,
    since it allows for completely different usage profiles depending on the mode, and actually even drastically
    different configuration data as well.</para>

   <para><xref linkend="concepts-modes-explained" /> should explain this in greater detail. For information on how
    to specify modes, see the User's Guide.</para>

   <figure id="concepts-modes-explained" float="1" pgwide="0" floatstyle="right">
    <title>Modes: nicer Runlevels</title>
    <mediaobject>
     <textobject>
      <para>illustrate all this right here.</para>
     </textobject>
    </mediaobject>
   </figure>

   <sect2 id="concepts-modes-switches">
    <title>Mode Switches</title>
    <titleabbrev>Mode Switches</titleabbrev>

    <para>A "Mode Switch" is what happens when you tell eINIT to go from one mode to another, for example if you
     tell eINIT to boot, it performs such a "Mode Switch" from nothing to "default". Shutting down and rebooting are
     also implemented as mode switches, in those cases they're from anything that is currently active to "power-down"
     or "power-reset", respectively. If you have a close look at modes.xml, you'll see that the latter two modes
     aren't even anything special, they're just tagged with some extra commands to run that will make eINIT do those
     special actions.</para>
   </sect2>
  </sect1>

  <sect1 id="concepts-events">
   <title>Events</title>
   <titleabbrev>Events</titleabbrev>

   <para>eINIT has a rather strong event-system that works a lot of the magic in the background. Events are all sorts
    of things that eINIT would want to act on, they include, but aren't limited to, notifications for module status
    changes, IPC requests from the user or other parts of eINIT, various requests (i.e. for switching modes, shutting
    down, etc.), module feedback, etc...</para>

   <para>Events work by having some modules register "handlers" or "listeners" for event subsystems. These handlers
    are functions, which get called whenever an event of that specific subsystem is emitted. Events can be emitted
    by any portion of the code, including code from modules.</para>

   <para><xref linkend="concepts-events-details" /> contains some details on the internals of this.</para>

   <figure id="concepts-events-details" float="1" pgwide="0" floatstyle="right">
    <title>Events</title>
    <mediaobject>
     <textobject>
      <para>illustrate all this right here.</para>
     </textobject>
    </mediaobject>
   </figure>

   <sect2 id="concepts-events-subsystems">
    <title>Events and Event Subsystems</title>
    <titleabbrev>Subsystems</titleabbrev>

    <para>As indicated in <xref linkend="concepts-events-details" />, all events have an ID that determine their type.
	 This ID is an integer, with the upper bits indicating a subsystem. Subsystems aren't actual subsystems of any form,
     they're just there to group certain types of events together.</para>

    <para>These subsystems are things such as "power", "ipc" and "core", and then events are things like "power failure
     imminent", "ipc request" or "request for core mode-switch".</para>
   </sect2>

   <sect2 id="concepts-events-ipc">
    <title>IPC Events</title>
    <titleabbrev>IPC Events</titleabbrev>

    <para>IPC events are a form of "catchall" for events. Like regular events, they have a subsystem: ipc. Unlike other
	 events, however, they don't have any meaningful byte-code for the actual request. Instead they require a string,
     which tells the event listeners what the ipc request is all about, and they turn that into a reply string.</para>

    <para>All listeners write their output (if any) to a FILE* structure that they get in the event-header. This pointer
     will either refer to stderr, to the stdout of an einit-control instance that caused the request, or to a pipe or
     a socket. The latter is a trick used by ipc-dbus to grab the output of ipc commands as strings.</para>

    <para>The command "einit-control" in all its forms (also including "power", "erc" and "einit-control-dbus", as well
     as most functions from libeinit) is used to create "raw" IPC requests: the command connects to einit in some form,
     requests an IPC to be emitted and the output of that is redirected to the client, which will most likely write it
     to stdout.</para>

    <para>One other curiousity of IPC requests is that they have a flag in the event handler,
     (struct einit_event *)->implemented, which must be set to anything but 0 to tell eINIT that an IPC command has been
     handled and was implemented.</para>
   </sect2>

   <sect2 id="concepts-events-relays">
    <title>Event Relays (e.g. via D-Bus)</title>
    <titleabbrev>Event Relays</titleabbrev>

    <para>An event "relay" is something that takes internal events and puts them onto some other system for other
     programs to play with. The only current example for this is the eINIT-D-Bus connector, which, among other things,
     can take internal events and push them to other programs on the system via dbus-signals.</para>
   </sect2>
  </sect1>

  <sect1 id="concepts-functions">
   <title>Registered Functions</title>
   <titleabbrev>Registered Functions</titleabbrev>

   <para>A "registered function" is way to share code or functions across modules. The main idea here is to allow
    big modules into smaller parts, for example one generic part and a system-dependant one (like the process-handler
    code or the mounter-modules).</para>

   <para>These functions get registered (or unregistered) with three attributes: a string, which identifies them,
    the function itself and a "version code". The latter is just an ordinary integer, but it's there to help you in case
    you ever decide to change the arguments of a function around: just bump the version number for your function, and
    all code that hasn't been updated yet won't "see" your function any more.</para>

   <para>For more details on using this, see the developer's guide, especially the part on C-modules.</para>
  </sect1>
 </appendix>

 <appendix id="credits">
  <title>Credits and Legalities</title>

  <para>Yes, we all love those legalities, don't we? Without further ado, here's (hopefully) all of the credits.</para>

  <note><para>If you feel left out, be assured that it wasn't on purpose. Just mail me and I'll add you to the
   list.</para></note>

  <sect1 id="credits-expat">
   <title>&lt;eXpat/&gt;</title>
   <titleabbrev>expat</titleabbrev>

   <para>This software relies on the expat library for parsing XML files, which is released under the following license
    terms.</para>

   <para>Copyright (c) 1998, 1999, 2000 Thai Open Source Software Center Ltd and Clark Cooper</para>
   <para>Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006 Expat maintainers.</para>
   <para>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
    documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
	rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to the following conditions:</para>
   <para>The above copyright notice and this permission notice shall be included in all copies or substantial portions
    of the Software.</para>
   <para>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
    TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.</para>

   <itemizedlist>
    <listitem><para><ulink url="http://expat.sourceforge.net/">Expat Homepage</ulink></para></listitem>
   </itemizedlist>
  </sect1>

  <sect1 id="credits-contributors">
   <title>Contributors</title>
   <titleabbrev>Contributors</titleabbrev>

   <para>This is in no particular order and might in fact accidentally omit one person or another. If you feel left
    out, please say so so i can add ya :)</para>

   <itemizedlist>
    <listitem><para>KKtm</para></listitem>
    <listitem><para>DieselPower</para></listitem>
    <listitem><para>AidanJT</para></listitem>
    <listitem><para>nikolavp</para></listitem>
    <listitem><para>niick</para></listitem>
    <listitem><para>teppic</para></listitem>
    <listitem><para>haader</para></listitem>
    <listitem><para>olof</para></listitem>
    <listitem><para>lonn</para></listitem>
    <listitem><para>yoyo</para></listitem>
    <listitem><para>Lloeki</para></listitem>
    <listitem><para>Janax</para></listitem>
    <listitem><para>shaumux</para></listitem>
   </itemizedlist>
  </sect1>

  <sect1 id="credits-authors">
   <title>Authors/Developers</title>
   <titleabbrev>Authors</titleabbrev>

   <para>Not many current "real" developers around, but since this is the credits section, might as well list us all.
    :D</para>

   <para>The order is straight from the "AUTHORS" file shipped with the XML modules, so it's pretty much the order in
    which people joined up.</para>

   <itemizedlist>
    <listitem><para>mdeininger/jyujin: Magnus Deininger, dma05@web.de</para></listitem>
    <listitem><para>rmh3093: Ryan Hope, rmh3093@gmail.com</para></listitem>
    <listitem><para>creidiki: Leonardo Valeri Manera, l.valerimanera@gmail.com</para></listitem>
   </itemizedlist>
  </sect1>

 </appendix>
</book>