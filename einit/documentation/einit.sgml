<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN">
<book lang="en">
 <bookinfo>
  <date>2006-10-02</date>
  <title>eINIT</title>
  <subtitle>User's Guide</subtitle>
  <authorgroup>
   <author>
    <firstname>Magnus</firstname>
    <surname>Deininger</surname>
   </author>
  </authorgroup>
  <copyright>
   <year>2006</year>
   <holder>Magnus Deininger</holder>
  </copyright>
  <legalnotice>
   <para>All rights reserved.</para>
   <para>Redistribution and use in source and binary forms, with or without modification,
    are permitted provided that the following conditions are met:</para>
   <itemizedlist>
    <listitem><para>Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.</para></listitem>
    <listitem><para>Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.</para></listitem>
    <listitem><para>Neither the name of the project nor the names of its contributors may be
     used to endorse or promote products derived from this software without
     specific prior written permission.</para></listitem>
   </itemizedlist>
   <para>
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  </para>
  </legalnotice>
  <abstract>
   <para>This Documentation was written with eINIT version 0.10 in mind. It was written to help new users find out how to use eINIT, and to help interested persons figure out what eINIT is all about.</para>
  </abstract>
 </bookinfo>

 <chapter id="introduction">
  <title>Introduction</title>
  <sect1 id="introduction-what-is-einit">
   <title>What is eINIT?</title>
   <titleabbrev>About</titleabbrev>
   <para>eINIT is an "Init-System" for Unix operating systems. To figure out what this means, I'll explain some things about how unices boot, and we'll use Linux on an x86 as an example.</para>
   <para>Whenever you turn on your computer, the following happens:
    <itemizedlist>
     <listitem><para>The CPU loads your BIOS</para></listitem>
     <listitem><para>Your BIOS sets up some devices and loads some bootloader off your HD (or whatever you're booting from)</para></listitem>
     <listitem><para>The bootloader loads Linux</para></listitem>
     <listitem><para>Linux mounts your root-filesystem and executes /sbin/init</para></listitem>
     <listitem><para>/sbin/init will start up all sorts of services, check and mount filesystems, run your X-Server, etc... </para></listitem>
     <listitem><para>Upon completion of all this, you can log in.</para></listitem>
    </itemizedlist>
   </para>
   <para>The /sbin/init part is what eINIT does.</para>
  </sect1>
  <sect1 id="introduction-advantages">
   <title>Didn't we have sysvinit for that?</title>
   <titleabbrev>Advantages</titleabbrev>
   <para>
    Yes, for example on Linux, your distributor will have put some clone of System-V's init in place. When this init is run by the kernel, it will read a file called "inittab" which contains information about what runlevel to boot, what scripts to run, etc. That usually results in an /sbin/rc or /etc/rc script to be run, which will in turn try to start a set of scripts. Then, upon completion of the rc-program, init will set up a set of ttys so that you can log-in and begin working.
   </para>
   <para>
    All of this works great and tends to be very stable, but it has some drawbacks (even though most of these might be irrelevant on fast machines):
    <itemizedlist>
     <listitem><para>Most rc-scripts don't handle dependencies: You have to list all the scripts that have to be started in the order they need to be started.</para></listitem>
     <listitem><para>Usually /etc/rc (or /sbin/rc) is a shell-script, and so are most of the things it starts directly: It takes time for your shell to parse these scripts. It's really not much time that is required, but this is done every single time your computer boots, which can be very bad for embedded devices that need to be up ASAP.</para></listitem>
     <listitem><para>Some things just can't be done (easily|efficiently) in a shell-script: Dependency-calculations tend to be slow (which is probably why there aren't many rc-scripts that do this) and parallel bootup is tricky.</para></listitem>
     <listitem><para>None of these scripts (or maybe programs) stay in memory, thus they can't store status information in RAM, so they often have to write things like PIDs and whether or not a service has already been started in files on your harddisk. This is slow, so sometimes people go ahead and put the part of their filesystem that contains such status information on a RAM-disk. Obviously, both of these methods have more overhead than simply storing a 2-byte PID and a flag that says "running" in-memory, and every single byte could count on an embedded device with limited resources.</para></listitem>
     <listitem><para>Often you will find many init-scripts that only start or stop a daemon that all look pretty much the same. Having more than one script like this is... well, redundant.</para></listitem>
     <listitem><para>It's hard to modify the "feedback" you get. To modify that, you would normally have to modify the main rc-script and maybe some other utility-script, maybe download a different version that gives you graphical feedback instead of textual one. It gets even more tricky when you have to rely on aural output, maybe because you're blind...</para></listitem>
     <listitem><para>You will hardly find an init/rc combination that allows for "backup-services", as in "should named fail to start, try to get dnsmaq up". Unless, of course, you craft a special script for that.</para></listitem>
     <listitem><para>You just can't have scripts that make sure a daemon keeps running, as in, one that resurrects a daemon should it be killed or die because it's buggy. You could, of course, write a daemon to do this for you...</para></listitem>
    </itemizedlist>
    eINIT tries to address all these problems.
   </para>
  </sect1>
    <sect1 id="introduction-differences-upstart">
   <title>Design differences between Upstart and eINIT</title>
   <titleabbrev>Differences to Upstart</titleabbrev>
   <para>
    Since just recently the Ubuntu crowd started hacking on their own init-replacement, called "Upstart", I thought that it might be a good time to point out the key differences between Upstart's and eINIT's design.
    <itemizedlist>
     <listitem><para>Upstart is designed to be completely event based -- eINIT will be partially event-based.</para></listitem>
     <listitem><para>eINIT is designed for embedded devices and things like headless servers.</para></listitem>
     <listitem><para>Upstart is designed with backwards-compatibility to sysv in mind, eINIT is not.</para></listitem>
    </itemizedlist>
   </para>
  </sect1>
  <sect1 id="introduction-features">
   <title>Current Features</title>
   <titleabbrev>Features</titleabbrev>
   <para>It's always nice to have a list of current features, so here we go:</para>
   <itemizedlist>
    <listitem><para>Highly modular</para></listitem>
    <listitem><para>Dependency calculations based on abstract "services".</para></listitem>
    <listitem><para>Parallel processing of modules</para></listitem>
    <listitem><para>Configuration files in XML</para></listitem>
    <listitem><para>"Modes": no cheap runlevels (see "Concepts")</para></listitem>
    <listitem><para>A module to start daemoni and make sure they keep running by restarting them in case they get killed</para></listitem>
    <listitem><para>No init-scripts required: no need to parse scripts on startup (comes in handy on embedded devices)</para></listitem>
    <listitem><para>BSD-License: Probably handy for corporate users that wish to modify eINIT without providing sources. (the module-interface would also allow for precompiled binary-only modules)</para></listitem>
   </itemizedlist>
  </sect1>
 </chapter>

 <chapter id="installation">
  <title>Installation</title>
  <sect1 id="installation-gentoo">
   <title>Installing eINIT on Gentoo/Linux</title>
   <titleabbrev>Gentoo/Linux</titleabbrev>
   <para>
    Since my main/favourite Linux distribution is Gentoo/Linux, I wrote some ebuilds for eINIT to faciliate testing and installation.
    <itemizedlist>
     <listitem><para>Step 1: Download this <ulink url="http://jyujin.de/~mdeininger/projects/einit-cvs-portage-overlay.tar.bz2">portage overlay</ulink> and unpack it into your portage overlay.</para></listitem>
     <listitem><para>Step 2: emerge eINIT:<synopsis>emerge -aNDv einit</synopsis> Note the "doc"-flag in this ebuild: if it is disabled, the user's guide and the API documentation will not be generated.</para></listitem>
    </itemizedlist>
    <note><para>THIS IS VERY IMPORTANT! If you have a separate /usr partition, you will have to make sure that expat is accessible before your /usr partition is mounted. Expat is usually installed in /usr/lib/ (and sometimes even in /usr/local/lib/), so you will need to copy /usr/lib/libexpat.* to /lib/.</para></note>
   </para>
  </sect1>
  <sect1 id="installation-manual">
   <title>Installing eINIT on other Linux distributions or other unices.</title>
   <titleabbrev>Anything but Gentoo/Linux</titleabbrev>
   <sect2 id="installation-aquiring">
    <title>Aquiring a copy of eINIT</title>
    <titleabbrev>Aquiring</titleabbrev>
    <para>
     The project page on sourceforge.net contains links to some releases of eINIT and instructions on how to download the CVS version.
    </para>
    <para><ulink url="https://sourceforge.net/projects/einit/">Project Page on SourceForge.net</ulink></para>
   </sect2>
   <sect2 id="installation-manual-compiling-installing">
    <title>Compiling and Installing eINIT</title>
    <titleabbrev>Compiling/Installing</titleabbrev>
    <para>
     This is easy, although just now the configure-script isn't very smart. Upon aquiring a copy of the current source-tree, bring up a console and cd into the root directory of the sources and run
     <synopsis>./configure [--enable-linux] --enable-posix-regex [--pthread-wait-bug]</synopsis>
     <note><para>DO use --enable-linux on linux, and only linux. Use the --help parameter to see more options. Especially the --prefix option could be of interest to you. Also, --enable-posix-regex is always a good idea.</para></note>
     <note><para>If your Unix system provides a buggy pthreads implementation that doesn't allow threads of one process to wait on another thread's children to die (this specifically applies to linux with a kernel < 2.4 and to linux with uclibc), you will need to specify --pthread-wait-bug.</para></note>
     This will get your sources ready for compilation. Now run
     <synopsis>make</synopsis>
     to compile everything, followed by
     <synopsis>make install</synopsis>
     to install eINIT. That is all.
     <note><para>THIS IS VERY IMPORTANT! If you have a separate /usr partition, you will have to make sure that expat is accessible before your /usr partition is mounted. Expat is usually installed in /usr/lib/ (and sometimes even in /usr/local/lib/), so you will need to copy /usr/lib/libexpat.* to /lib/.</para></note>
    </para>
   </sect2>
  </sect1>
  <sect1 id="installation-configuration">
   <title>Configuring eINIT</title>
   <titleabbrev>Configuring</titleabbrev>
   <para>
    The main (default) configuration file is <filename>/etc/einit/default.xml</filename>, the file you should modify is <filename>/etc/einit/rc.xml</filename>. It's an ordinary XML file, so any editor will do, and the file format should be fairly straightforward. For details, see the chapter on configuring eINIT.
   </para>
  </sect1>
  <sect1 id="installation-configuration-boot">
   <title>Configuring your System to use eINIT</title>
   <titleabbrev>eINIT and Boot-Loaders</titleabbrev>
   <para>
    In order for your unix-system to use eINIT instead of your regular init, you have to either replace the original init or make your kernel use a different init-binary.
   </para>
   <sect2 id="installation-configuration-boot-replacing">
    <title>Replacing your current init with eINIT</title>
    <titleabbrev>INIT=eINIT</titleabbrev>
    <para>
     The easy and pretty much surefire way to do this.
     <synopsis>ln -sf einit /sbin/init</synopsis>
    </para>
    <note><para>This practice is NOT recommended right now, as eINIT is still alpha-software!</para></note>
   </sect2>
   <sect2 id="installation-configuration-boot-linux-grub">
    <title>[LINUX] Configuring GRUB</title>
    <titleabbrev>GRUB</titleabbrev>
    <para>
     Modify your /boot/grub/grub.conf or /boot/grub/menu.lst or similar. Search for your current kernel entry, duplicate the whole section and add "init=/sbin/einit" to the kernel command line.
    </para>
   </sect2>
   <sect2 id="installation-configuration-boot-linux-lilo">
    <title>[LINUX] Configuring LILO</title>
    <titleabbrev>LILO</titleabbrev>
    <para>
     Modify your /etc/lilo.conf. Search for your current kernel entry, duplicate the whole section and add "init=/sbin/einit" to the kernel command line, then issue the command
     <synopsis>lilo</synopsis>
     on a root-console.
    </para>
   </sect2>
  </sect1>
 </chapter>

 <chapter id="concepts">
  <title>Concepts</title>
  <para>Since we're trying to be revolutionary, we're bound to do some things differently, aren't we?</para>
  <sect1 id="concepts-modes">
   <title>Modes</title>
   <titleabbrev>modes</titleabbrev>
   <para>
    A <quote>mode</quote> is a set of modules and settings for said modules that belong together to form a sort of "usage profile" for your Unix-machine. Modes are related to sysvinit's runlevels, except that they not only contain a set of processes that need to be run to form a runlevel, but that eINIT supports configuration entries to be associated with modes. Also eINIT is not limited to 6/7 runlevels (level 1 through 6 and S, with the mentioned three
    already having a special meaning), but it allows for an arbitrary number of named modes, each of which can depend on a set of other modes.
   </para>
   <para>
    Okay, this is admittedly a tad abstract, so let's try to make this a bit more clear. As has been mentioned, modes can form a sort of usage-profile for your computer. Thus you could have one mode for "server", one for "workstation". Now, when you think about it, both require the same set of basic initialisation: mounting filesystems, setting up hardware, monitoring hardware events... and doing all these things alone would probably be sufficient for a single-user session, so we make this a new mode and call it "boot". Now we have three modes: boot, server and workstation, with server and workstation both depending on boot. That means you can put all the common modules into boot and concentrate on which services you wish to start in the server mode (network, firewall, apache, mysql) and which to start in the workstation mode (X11, e17...). Now, when eINIT boots (or switches modes) to either of "server" or "workstation", it will take all the entries in "boot" into consideration as well and it will make sure that everything is loaded with a minimum of changes to whatever is running right now, doing as much as possible in parallel.
   </para>
   <para>
    And when you think about this a little harder, the server mode is just an extended "firewall" or "router"-mode... you get the drift :D
   </para>
  </sect1>
 </chapter>

 <chapter id="configuration">
  <title>The Configuration Files.</title>
  <titleabbrev>/etc/einit</titleabbrev>
  <para>eINIT uses XML files to store its configuration. These files are located in /etc/einit, the default files are:
   <itemizedlist>
    <listitem><para><filename>default.xml</filename>: This is the "entry point" for eINIT. Whenever it starts, it will load and process this file.</para></listitem>
    <listitem><para><filename>sandbox.xml</filename>: This is the "entry point" for eINIT if it was compiled in "sandbox-mode".</para></listitem>
    <listitem><para><filename>daemon.xml</filename>: daemon definitions (sshd, xdm, ...)</para></listitem>
    <listitem><para><filename>shell.xml</filename>: command-based module definitions (keyboard setup, clock synchronisation, ...)</para></listitem>
    <listitem><para><filename>rc.xml</filename>: all configuration details that are specific to the host that einit is run on go into this file; this is the file you should modify.</para></listitem>
   </itemizedlist>
  </para>
  <sect1 id="configuration-generic">
   <title>Configuration File Layout</title>
   <titleabbrev>file layout</titleabbrev>
   <para>
    eINIT configuration files look like this:
   </para>
   <synopsis label="sample XML-configuration file">
    &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
    &lt;einit&gt;
     &lt;!-- [...] --&gt;

     &lt;decimal-integer-variable i="10" /&gt;
     &lt;octal-integer-variable oi="8" /&gt;
     &lt;binary-integer-variable bi="8" /&gt;
     &lt;string-variable s="string" /&gt;
     &lt;mixed-type-variable s="string" i="10" /&gt;
     &lt;boolean-true-variable b="enabled" /&gt;
     &lt;boolean-false-variable b="false" /&gt;

     &lt;!-- [...] --&gt;

     &lt;mode id="default" base="boot"&gt;
      &lt;enable mod="module1:module2:module3" /&gt;
      &lt;variable1 s="contents" /&gt;
     &lt;/mode&gt;
    &lt;/einit&gt;
   </synopsis>
   <para>
    if we examine this fictional snippet, we can observe the following:
    <itemizedlist>
     <listitem>
      <para>eINIT configuration files are regular, free-form XML files. They need to be syntactically correct (don't forget the / in elements! For example <varname>&lt;decimal-integer-variable /&gt;</varname> instead of <varname>&lt;decimal-integer-variable&gt;</varname>) and should be written in UTF-8.</para>
     </listitem>
     <listitem><para>Most elements define variables.</para></listitem>
     <listitem><para>The only (inner) element that contains elements is the <varname>&lt;mode /&gt;</varname>-element.</para></listitem>
     <listitem><para>Values are assigned to elements using attributes, i.e. <varname>&lt;variable s="string" /&gt;</varname> as opposed to <varname>&lt;variable&gt;string&lt;/variable&gt;</varname>. This is different from most other programs that use XML files for configuration, but I find this way to be more logical and intuitive.</para></listitem>
     <listitem><para>The type of a value is determined by the attribute that is used: The attribute <varname>i=""</varname> specifies an decimal integer value, <varname>s=""</varname> a string, <varname>bi=""</varname> a binary integer, <varname>oi=""</varname> an octal integer and <varname>b=""</varname> specifies a boolean flag (the values "true", "enabled" and "yes" mean the flag is on, everything else means the flag is off).</para></listitem>
     <listitem><para>A variable can have more than one type of value: it can be a string, a boolean and an integer at the same time. Which of the values is used is up to the using module to decide.</para></listitem>
     <listitem><para>A "set" of strings is always a string of the form "element1:element2", i.e. a string where the elements are delimited using a colon (':').</para></listitem>
    </itemizedlist>
   </para>
   <sect2 id="configuration-generic-special">
    <title>Special Variables</title>
    <titleabbrev>special variables</titleabbrev>
    <para>Some variables have a special meaning to eINIT's core:</para>
    <synopsis label="sample XML-configuration file">
     &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
     &lt;einit&gt;
      &lt;!-- [...] --&gt;

      &lt;module-path s="/lib/einit" /&gt;
      &lt;configuration-path s="/etc/einit/" /&gt;

      &lt;include s="file-to-include.xml" /&gt;

      &lt;!-- [...] --&gt;
     &lt;/einit&gt;
    </synopsis>
    <variablelist><title>Special Variables</title>
     <varlistentry>
      <term><varname>module-path</varname> [STRING]</term>
      <listitem>
       <para>
        The default path for ".so-modules" (i.e. those loaded using the dynamic linker). This variable is mandatory, and you should not mess with it unless you know what you're doing.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>configuration-path</varname> [STRING]</term>
      <listitem>
       <para>
        The base path for configuration files. Also mandatory, and you shouldn't mess with the default.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>include</varname> [STRING]</term>
      <listitem>
       <para>
        This is used to include other configuration files. The specified string is a filename relative to the <varname>configuration-path</varname>. Use this to split the configuration into smaller parts for easier handling (see above for the default files).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>
   <sect2 id="configuration-generic-modes">
    <title>Mode configuration</title>
    <titleabbrev>modes</titleabbrev>
    <para>As has been mentioned, modes are the only elements with subelements. Consider this configuration sample:</para>
    <synopsis label="sample XML-configuration file">
     &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
     &lt;einit&gt;
      &lt;!-- [...] --&gt;

      &lt;variable1 s="x" /&gt;

      &lt;mode id="boot"&gt;
       &lt;enable mod="module4:module6" /&gt;
      &lt;/mode&gt;

      &lt;mode id="default" base="boot"&gt;
       &lt;enable mod="module1:module2:module3" /&gt;
       &lt;disable mod="module4:module5" /&gt;
       &lt;reset mod="module6" /&gt;
       &lt;variable1 s="not x" /&gt;
      &lt;/mode&gt;

      &lt;!-- [...] --&gt;
     &lt;/einit&gt;
    </synopsis>
    <para>This sample defined the modes "default" and "boot", where "default" depends on "boot". This means that default can be considered an "extension" of boot: boot is a complete mode that can be enabled and handled like all other modes, and so is default. However, if you tell einit to switch to the mode "default", then it will do all the regular dependeny calculations but it will also include the <varname>enable</varname>, <varname>disable</varname> and <varname>reset</varname> statements in the boot-mode, as if they had been specified in the default mode.</para>
    <para>Something else that should be noted: notice the element <varname>variable1</varname> in the definition of the mode "default"? This demonstrates how you can have variables that are "global" and how you can have them overriden in modes: Whenever eINIT searches for a variable, it first searches in the mode that is currently enabled (or the one that is to be enabled), then it looks for variables that are not attached to any mode. This means: in our example if you switched to mode "default" and a module requested the variable "variable1", then it would get the string "not x". If you switched to mode "boot", then "variable1" would be the string "x".</para>
    <variablelist><title>Attributes in Mode-Definitions</title>
     <varlistentry>
      <term>Element <varname>mode</varname>, Attribute <varname>id</varname> [STRING]</term>
      <listitem>
       <para>
        The name of this mode.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Element <varname>mode</varname>, Attribute <varname>base</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        IDs of other modes that this mode is based upon (see above for an explanation).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <variablelist><title>Elements and Attributes in Modes</title>
     <varlistentry>
      <term>Element <varname>enable</varname>, Attribute <varname>mod</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        A colon-separated set of service names that should be enabled if einit is instructed to switch to this mode.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Element <varname>disable</varname>, Attribute <varname>mod</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        A colon-separated set of service names that should be disabled if einit is instructed to switch to this mode.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Element <varname>reset</varname>, Attribute <varname>mod</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        A colon-separated set of service names that should be reset if einit is instructed to switch to this mode.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>
   <sect2 id="configuration-generic-services">
    <title>Special Service-Variables: Preferring some Modules over others.</title>
    <titleabbrev>special service-variables</titleabbrev>
    <synopsis label="sample XML-configuration file">
     &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
     &lt;einit&gt;
      &lt;!-- [...] --&gt;

      &lt;prefer-servicename1 s="module1:module2:module3:module4" /&gt;
      &lt;prefer-servicename2 s="module5" /&gt;

      &lt;prefer-xdm s="daemon-gdm:daemon-entrance" /&gt;

      &lt;!-- [...] --&gt;
     &lt;/einit&gt;
    </synopsis>
    <para>
     Suppose you have three modules that provide the service "xdm": daemon-gdm, daemon-kdm, daemon-entrance. If you requested the service "xdm" to be enabled (for example in a mode-switch, or using the erc command), you would get these three modules, but the order in which these three modules would be tried is unspecified. Using the prefer-xdm element in this example, we tell einit to re-order these modules, so that daemon-gdm is the first to be tried, daemon-entrance is the second, and anything else (daemon-kdm in our example) is tried after that.
    </para>
    <para>
     Note that these sections only apply to any modules found using that exact service name: if you requested a service named "x11" and daemon-kdm and daemon-gdm would also provide this service, then the service-xdm variable would not affect the order that these two modules would be tried in.
    </para>
    <variablelist><title>Module-preference</title>
     <varlistentry>
      <term><varname>prefer-&lt;service&gt;</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        A colon-separated set of module-ids. Replace &lt;service&gt; with the service name for which you want to specify module-preferences.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>
  </sect1>

  <sect1 id="configuration-modules">
   <title>Default Modules</title>
   <titleabbrev>default modules</titleabbrev>
   <para>
    When I mentioned that eINIT was heavily modular, I was *not* kidding: almost all services that eINIT provides are actually provided by modules, including TTY initialisation, shell-command exection and daemon-supervision.
   </para>
   <para>
    Most of these modules use special configuration elements that are parsed by them, this section should help you find out what configuration elements there are and which modules use them.
   </para>
   <sect2 id="configuration-modules-einit-tty">
    <title>[einit-tty] Specifying TTYs</title>
    <para>
     The "einit-tty" module is used to initialise terminals. Unlike sysv-init, your terminals will be brought up ASAP, which means they're usually up after the critical filesystems are mounted.
    </para>
    <synopsis label="sample XML-configuration file">
     &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
     &lt;einit&gt;
      &lt;!-- [...] --&gt;
      &lt;!-- tty initialisation --&gt;
      &lt;tty1-regular dev="/dev/tty1" command="/sbin/agetty 38400 tty1" restart="yes" TERM="linux" /&gt;
      &lt;tty2-regular dev="/dev/tty2" command="/sbin/agetty 38400 tty2" restart="yes" TERM="linux" /&gt;
      &lt;!-- [...] --&gt;

      &lt;mode id="default" base="boot"&gt;
       &lt;enable mod="tty" /&gt;
       &lt;ttys s="tty1-regular:tty2-regular" /&gt;
      &lt;/mode&gt;
     &lt;/einit&gt;
    </synopsis>
    <para>In this example configuration file, we initialise two terminals <varname>tty1-regular</varname> and <varname>tty2-regular</varname>. This is ensured by the &lt;enable /&gt;-tag inside the &lt;mode /&gt;-tag with id="default". The &lt;enable /&gt;-tag contains a mod="tty" attribute that tells eINIT to load a tty-module upon entering this mode. Then the &lt;ttys /&gt;-tag in the &lt;mode /&gt;-tag tells einit-tty (or any other tty-module, should there be another one with a higher preference) to enable the ttys tty1-regular and tty2-regular (you can put an arbitrarily long list of colon-separated tty-names inside the s="" attribute of this tag).</para>
    <para><varname>tty1-regular</varname> is defined as
     <synopsis>      &lt;tty1-regular dev="/dev/tty1" command="/sbin/agetty 38400 tty1" restart="yes" /&gt;</synopsis>
     The tag-name is the name that is mentioned in the enable-ttys-tag. You can choose whatever you wish here, including colourful swearing for all I care, the only constraints imposed on this is that it's a valid xml-tag-name and that it doesn't include a colon, for obvious reasons. The attribute
     <synopsis>dev="/dev/tty1"</synopsis> doesn't do anything yet, but it's reserved to be used as a device identifier. You may omit this for now, albeit that would mean to risk breaking your configuration later.
     <synopsis>command="/sbin/agetty 3800 tty1"</synopsis> This attribute tells einit-tty what command to run to get the specified tty up and running. The agetty-command in this example is intended for linux users, as most linux distributions will include agetty.
     <synopsis>restart="yes"</synopsis> Whether to restart the specified getty-command, should it die. The default is not to restart a dead tty, so you will want to specify this option.
    </para>
    <variablelist><title>Service Names and used Variables</title>
     <varlistentry>
      <term>Service <varname>tty</varname></term>
      <listitem>
       <para>
        Enable this service to enable ttys, disable to kill all ttys, reset to kill all those ttys that are enabled but should not be enabled in this mode and enable those that aren't enabled yet.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Variable <varname>ttys</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        A colon-separated set of strings specifying tty-definition variables.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <variablelist><title>TTY-Variable Attributes</title>
     <varlistentry>
      <term>Attribute <varname>dev</varname> [STRING]</term>
      <listitem>
       <para>
        Path to a tty device-file. (This is currently ignored)
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Attribute <varname>command</varname> [STRING]</term>
      <listitem>
       <para>
        The command to run for the tty to get up. (i.e. the getty binary with parametres)
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Attribute <varname>restart</varname> [BOOLEAN]</term>
      <listitem>
       <para>
        Whether or not to restart the TTY if it dies.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>All remaining Attributes</term>
      <listitem>
       <para>
        These attributes are added to the command's environment as variable=value pairs upon execution.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>
   <sect2 id="configuration-modules-einit-mod-exec">
    <title>einit-mod-exec</title>
    <para>
     This module is used to create pseudo-modules that execute arbitrary shell-commands.
    </para>
    <synopsis label="sample XML-configuration file">
     &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
     &lt;einit&gt;
      &lt;!-- [...] --&gt;
      &lt;mod-shell id="shell-mount" name="Filesystems" provides="localmount" requires="sysconf"
       enable="mount -a" disable="umount -ar; mount / -o remount,ro" /&gt;
      &lt;!-- [...] --&gt;

      &lt;mode id="boot"&gt;
       &lt;enable mod="localmount" /&gt;
      &lt;/mode&gt;
     &lt;/einit&gt;
    </synopsis>
    <para>In this excerpt from the default configuration file, we see the definition of a module called "shell-mount", that goes by the name of "Filesystems". It provides a module for the "localmount"-requirement, which is required in our exemplary "boot"-mode. Additionally, it requires a "sysconf"-module to be enabled before it. The attributes <varname>enable=</varname> and <varname>disable=</varname> specify what commands to run upon enabling or disabling this pseudo-module.</para>
   </sect2>
   <sect2 id="usage-modules-einit-mod-daemon">
    <title>einit-mod-daemon</title>
    <para>
     One of the things I criticized about sysvinit was that there was no way to ensure that a daemon keeps running with only shell-scripts. This module provides exactly this functionality: You can have a special pseudo-module created that only loads a daemon, and that will resurrect this daemon if it dies.
    </para>
    <synopsis label="sample XML-configuration file">
     &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
     &lt;einit&gt;
      &lt;!-- [...] --&gt;
      &lt;mod-daemon id="daemon-gpm" name="GPM" provides="gpm" requires="sysconf:tty"
       command="/usr/sbin/gpm" restart="yes" /&gt;
      &lt;!-- [...] --&gt;

      &lt;mode id="default" base="boot"&gt;
       &lt;enable mod="gpm" /&gt;
      &lt;/mode&gt;
     &lt;/einit&gt;
    </synopsis>
    <para>The mod-daemon-tag is very similar to the mod-shell tag. In this example we see that requires="" and provides="" is actually interpreted as a colon-separated list; this is also true for the mod-shell tag. Instead of the enable="" and disable="" attributes, we have one command="" attribute that is used to specify a command that needs to be run to get this daemon up. Also this tag sports a special restart="" attribute, that tells einit-mod-daemon whether to resurrect a dead daemon or not.</para>
   </sect2>
   <sect2 id="usage-modules-einit-feedback-textual">
    <title>einit-feedback-textual</title>
    <para>
     This is the default feedback-module. It comments on certain events, like modules being enabled or disabled; verbose output from the modules is also put on-screen. Developers could use the source file of this module to create other, more complex feedback modules.
    </para>
   </sect2>
  </sect1>
 </chapter>

 <chapter id="usage">
  <title>Usage</title>
  <sect1 id="usage-einit-control">
   <title>Interfacing with eINIT: einit-control</title>
   <titleabbrev>einit-control</titleabbrev>
   <synopsis>einit-control [-h]</synopsis>
   <synopsis>einit-control [-s control-socket] [function] command</synopsis>
   <para>
    This is the main command to control eINIT: it connects to socket <varname>control-socket</varname> and submits <varname>function</varname> and <varname>command</varname> for eINIT to interpret.
   </para>
   <note><para>The "power", "erc" and "rc" commands are usually (sym-)linked to the einit-control binary. For example, calling <userinput>einit-control power off</userinput> is the same as calling <userinput>power off</userinput>, if the proper links are in place.</para></note>
   <sect2 id="usage-einit-control-power">
    <title>The "power"-command</title>
    <titleabbrev>power</titleabbrev>
    <synopsis>power [-h]</synopsis>
    <synopsis>power [-s control-socket] command</synopsis>
    <synopsis>einit-control [-s control-socket] power command</synopsis>
    <para>
     This command is used to tell eINIT that you wish to shut down or reboot your computer. The <varname>command</varname> must bei either of <userinput>off</userinput> or <userinput>reset</userinput>, which will tell eINIT to power off or reset, respectively.
    </para>
   </sect2>
   <sect2 id="usage-einit-control-erc">
    <title>The "erc" and "rc"-commands</title>
    <titleabbrev>erc</titleabbrev>
    <synopsis>[e]rc [-h]</synopsis>
    <synopsis>[e]rc [-s control-socket] command</synopsis>
    <synopsis>einit-control [-s control-socket] rc command</synopsis>
    <para>
     This command is used to tell eINIT that you wish to change modes or enable/disable a module.
    </para>
    <synopsis>[e]rc [-s control-socket] switch-mode mode</synopsis>
    <para>
     Make eINIT switch to the specified <varname>mode</varname>
    </para>
    <synopsis>[e]rc [-s control-socket] module (enable|disable)</synopsis>
    <para>
     Make eINIT enable or disable the specified <varname>module</varname>.
    </para>
    <note><para>Whether the command is/should be named rc or erc depends on the environment: if you only set up a test-environment, you would want the command to be called "erc", because sysvinit usually depends on an /sbin/rc command to do some of the dirty work.</para></note>
   </sect2>
  </sect1>
 </chapter>
</book>