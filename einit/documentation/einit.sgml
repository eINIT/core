<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN">
<book lang="en">
 <bookinfo>
  <date>2006-10-02</date>
  <title>eINIT</title>
  <subtitle>User's Guide</subtitle>
  <authorgroup>
   <author>
    <firstname>Magnus</firstname>
    <surname>Deininger</surname>
   </author>
  </authorgroup>
  <copyright>
   <year>2006</year>
   <holder>Magnus Deininger</holder>
  </copyright>
  <legalnotice>
   <para>All rights reserved.</para>
   <para>Redistribution and use in source and binary forms, with or without modification,
    are permitted provided that the following conditions are met:</para>
   <itemizedlist>
    <listitem><para>Redistributions of source code must retain the above copyright notice,
     this list of conditions and the following disclaimer.</para></listitem>
    <listitem><para>Redistributions in binary form must reproduce the above copyright notice,
     this list of conditions and the following disclaimer in the documentation
     and/or other materials provided with the distribution.</para></listitem>
    <listitem><para>Neither the name of the project nor the names of its contributors may be
     used to endorse or promote products derived from this software without
     specific prior written permission.</para></listitem>
   </itemizedlist>
   <para>
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
    ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
    ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  </para>
  </legalnotice>
  <abstract>
   <para>This Documentation was written with eINIT version 0.10 in mind. It was written to help new users find out how to use eINIT, and to help interested persons figure out what eINIT is all about.</para>
  </abstract>
 </bookinfo>

 <chapter id="introduction">
  <title>Introduction</title>
  <sect1 id="introduction-what-is-einit">
   <title>What is eINIT?</title>
   <titleabbrev>About</titleabbrev>
   <para>eINIT is an "Init-System" for Unix operating systems. To figure out what this means, I'll explain some things about how unices boot, and we'll use Linux on an x86 as an example.</para>
   <para>Whenever you turn on your computer, the following happens:
    <itemizedlist>
     <listitem><para>The CPU loads your BIOS</para></listitem>
     <listitem><para>Your BIOS sets up some devices and loads some bootloader off your HD (or whatever you're booting from)</para></listitem>
     <listitem><para>The bootloader loads Linux</para></listitem>
     <listitem><para>Linux mounts your root-filesystem and executes /sbin/init</para></listitem>
     <listitem><para>/sbin/init will start up all sorts of services, check and mount filesystems, run your X-Server, etc... </para></listitem>
     <listitem><para>Upon completion of all this, you can log in.</para></listitem>
    </itemizedlist>
   </para>
   <para>The /sbin/init part is what eINIT does.</para>
  </sect1>
  <sect1 id="introduction-advantages">
   <title>Didn't we have sysvinit for that?</title>
   <titleabbrev>Advantages</titleabbrev>
   <para>
    Yes, for example on Linux, your distributor will have put some clone of System-V's init in place. When this init is run by the kernel, it will read a file called "inittab" which contains information about what runlevel to boot, what scripts to run, etc. That usually results in an /sbin/rc or /etc/rc script to be run, which will in turn try to start a set of scripts. Then, upon completion of the rc-program, init will set up a set of ttys so that you can log-in and begin working.
   </para>
   <para>
    All of this works great and tends to be very stable, but it has some drawbacks (even though most of these might be irrelevant on fast machines):
    <itemizedlist>
     <listitem><para>Most rc-scripts don't handle dependencies: You have to list all the scripts that have to be started in the order they need to be started.</para></listitem>
     <listitem><para>Usually /etc/rc (or /sbin/rc) is a shell-script, and so are most of the things it starts directly: It takes time for your shell to parse these scripts. It's really not much time that is required, but this is done every single time your computer boots, which can be very bad for embedded devices that need to be up ASAP.</para></listitem>
     <listitem><para>Some things just can't be done (easily|efficiently) in a shell-script: Dependency-calculations tend to be slow (which is probably why there aren't many rc-scripts that do this) and parallel bootup is tricky.</para></listitem>
     <listitem><para>None of these scripts (or maybe programs) stay in memory, thus they can't store status information in RAM, so they often have to write things like PIDs and whether or not a service has already been started in files on your harddisk. This is slow, so sometimes people go ahead and put the part of their filesystem that contains such status information on a RAM-disk. Obviously, both of these methods have more overhead than simply storing a 2-byte PID and a flag that says "running" in-memory, and every single byte could count on an embedded device with limited resources.</para></listitem>
     <listitem><para>Often you will find many init-scripts that only start or stop a daemon that all look pretty much the same. Having more than one script like this is... well, redundant.</para></listitem>
     <listitem><para>It's hard to modify the "feedback" you get. To modify that, you would normally have to modify the main rc-script and maybe some other utility-script, maybe download a different version that gives you graphical feedback instead of textual one. It gets even more tricky when you have to rely on aural output, maybe because you're blind...</para></listitem>
     <listitem><para>You will hardly find an init/rc combination that allows for "backup-services", as in "should named fail to start, try to get dnsmaq up". Unless, of course, you craft a special script for that.</para></listitem>
     <listitem><para>You just can't have scripts that make sure a daemon keeps running, as in, one that resurrects a daemon should it be killed or die because it's buggy. You could, of course, write a daemon to do this for you...</para></listitem>
    </itemizedlist>
    eINIT tries to address all these problems.
   </para>
  </sect1>
    <sect1 id="introduction-differences-upstart">
   <title>Design differences between Upstart and eINIT</title>
   <titleabbrev>Differences to Upstart</titleabbrev>
   <para>
    Since just recently the Ubuntu crowd started hacking on their own init-replacement, called "Upstart", I thought that it might be a good time to point out the key differences between Upstart's and eINIT's design.
    <itemizedlist>
     <listitem><para>Upstart is designed to be completely event based -- eINIT will be partially event-based.</para></listitem>
     <listitem><para>eINIT is designed for embedded devices and things like headless servers.</para></listitem>
     <listitem><para>Upstart is designed with backwards-compatibility to sysv in mind, eINIT is not.</para></listitem>
    </itemizedlist>
   </para>
  </sect1>
  <sect1 id="introduction-features">
   <title>Current Features</title>
   <titleabbrev>Features</titleabbrev>
   <para>It's always nice to have a list of current features, so here we go:</para>
   <itemizedlist>
    <listitem><para>Highly modular</para></listitem>
    <listitem><para>Dependency calculations based on abstract "services".</para></listitem>
    <listitem><para>Parallel processing of modules</para></listitem>
    <listitem><para>Configuration files in XML</para></listitem>
    <listitem><para>"Modes": no cheap runlevels (see "Concepts")</para></listitem>
    <listitem><para>A module to start daemoni and make sure they keep running by restarting them in case they get killed</para></listitem>
    <listitem><para>No init-scripts required: no need to parse scripts on startup (comes in handy on embedded devices)</para></listitem>
    <listitem><para>BSD-License: Probably handy for corporate users that wish to modify eINIT without providing sources. (the module-interface would also allow for precompiled binary-only modules)</para></listitem>
   </itemizedlist>
  </sect1>
 </chapter>

 <chapter id="installation">
  <title>Installation</title>
  <sect1 id="installation-gentoo">
   <title>Installing eINIT on Gentoo/Linux</title>
   <titleabbrev>Gentoo/Linux</titleabbrev>
   <para>
    Since my main/favourite Linux distribution is Gentoo/Linux, I wrote some ebuilds for eINIT to faciliate testing and installation.
    <itemizedlist>
     <listitem><para>Step 1: Download this <ulink url="http://jyujin.de/~mdeininger/projects/einit-cvs-portage-overlay.tar.bz2">portage overlay</ulink> and unpack it into your portage overlay.</para></listitem>
     <listitem><para>Step 2: emerge eINIT:<synopsis>emerge -aNDv einit</synopsis> Note the "doc"-flag in this ebuild: if it is disabled, the user's guide and the API documentation will not be generated.</para></listitem>
    </itemizedlist>
    <note><para>THIS IS VERY IMPORTANT! If you have a separate /usr partition, you will have to make sure that expat is accessible before your /usr partition is mounted. Expat is usually installed in /usr/lib/ (and sometimes even in /usr/local/lib/), so you will need to copy /usr/lib/libexpat.* to /lib/.</para></note>
   </para>
  </sect1>
  <sect1 id="installation-manual">
   <title>Installing eINIT on other Linux distributions or other unices.</title>
   <titleabbrev>Anything but Gentoo/Linux</titleabbrev>
   <sect2 id="installation-aquiring">
    <title>Aquiring a copy of eINIT</title>
    <titleabbrev>Aquiring</titleabbrev>
    <para>
     The project page on sourceforge.net contains links to some releases of eINIT and instructions on how to download the CVS version.
    </para>
    <para><ulink url="https://sourceforge.net/projects/einit/">Project Page on SourceForge.net</ulink></para>
   </sect2>
   <sect2 id="installation-manual-compiling-installing">
    <title>Compiling and Installing eINIT</title>
    <titleabbrev>Compiling/Installing</titleabbrev>
    <para>
     This is easy, although just now the configure-script isn't very smart. Upon aquiring a copy of the current source-tree, bring up a console and cd into the root directory of the sources and run
     <synopsis>./configure [--enable-linux] --enable-posix-regex [--pthread-wait-bug]</synopsis>
     <note><para>DO use --enable-linux on linux, and only linux. Use the --help parameter to see more options. Especially the --prefix option could be of interest to you. Also, --enable-posix-regex is always a good idea.</para></note>
     <note><para>If your Unix system provides a buggy pthreads implementation that doesn't allow threads of one process to wait on another thread's children to die (this specifically applies to linux with a kernel < 2.4 and to linux with uclibc), you will need to specify --pthread-wait-bug.</para></note>
     This will get your sources ready for compilation. Now run
     <synopsis>make</synopsis>
     to compile everything, followed by
     <synopsis>make install</synopsis>
     to install eINIT. That is all.
     <note><para>THIS IS VERY IMPORTANT! If you have a separate /usr partition, you will have to make sure that expat is accessible before your /usr partition is mounted. Expat is usually installed in /usr/lib/ (and sometimes even in /usr/local/lib/), so you will need to copy /usr/lib/libexpat.* to /lib/.</para></note>
    </para>
   </sect2>
  </sect1>
  <sect1 id="installation-configuration">
   <title>Configuring eINIT</title>
   <titleabbrev>Configuring</titleabbrev>
   <para>
    The main (default) configuration file is <filename>/etc/einit/default.xml</filename>, the file you should modify is <filename>/etc/einit/rc.xml</filename>. It's an ordinary XML file, so any editor will do, and the file format should be fairly straightforward. For details, see the chapter on configuring eINIT.
   </para>
  </sect1>
  <sect1 id="installation-configuration-boot">
   <title>Configuring your System to use eINIT</title>
   <titleabbrev>eINIT and Boot-Loaders</titleabbrev>
   <para>
    In order for your unix-system to use eINIT instead of your regular init, you have to either replace the original init or make your kernel use a different init-binary.
   </para>
   <sect2 id="installation-configuration-boot-replacing">
    <title>Replacing your current init with eINIT</title>
    <titleabbrev>INIT=eINIT</titleabbrev>
    <para>
     The easy and pretty much surefire way to do this.
     <synopsis>ln -sf einit /sbin/init</synopsis>
    </para>
    <note><para>This practice is NOT recommended right now, as eINIT is still alpha-software!</para></note>
   </sect2>
   <sect2 id="installation-configuration-boot-linux-grub">
    <title>[LINUX] Configuring GRUB</title>
    <titleabbrev>GRUB</titleabbrev>
    <para>
     Modify your /boot/grub/grub.conf or /boot/grub/menu.lst or similar. Search for your current kernel entry, duplicate the whole section and add "init=/sbin/einit" to the kernel command line.
    </para>
   </sect2>
   <sect2 id="installation-configuration-boot-linux-lilo">
    <title>[LINUX] Configuring LILO</title>
    <titleabbrev>LILO</titleabbrev>
    <para>
     Modify your /etc/lilo.conf. Search for your current kernel entry, duplicate the whole section and add "init=/sbin/einit" to the kernel command line, then issue the command
     <synopsis>lilo</synopsis>
     on a root-console.
    </para>
   </sect2>
  </sect1>
 </chapter>

 <chapter id="configuration">
  <title>The Configuration Files.</title>
  <titleabbrev>/etc/einit</titleabbrev>
  <para>eINIT uses XML files to store its configuration. These files are located in /etc/einit, the default files are:
   <itemizedlist>
    <listitem><para><filename>default.xml</filename>: This is the "entry point" for eINIT. Whenever it starts, it will load and process this file.</para></listitem>
    <listitem><para><filename>sandbox.xml</filename>: This is the "entry point" for eINIT if it was compiled in "sandbox-mode".</para></listitem>
    <listitem><para><filename>daemon.xml</filename>: daemon definitions (sshd, xdm, ...)</para></listitem>
    <listitem><para><filename>shell.xml</filename>: command-based module definitions (keyboard setup, clock synchronisation, ...)</para></listitem>
    <listitem><para><filename>rc.xml</filename>: all configuration details that are specific to the host that einit is run on go into this file; this is the file you should modify.</para></listitem>
   </itemizedlist>
  </para>
  <sect1 id="configuration-generic">
   <title>Configuration File Layout</title>
   <titleabbrev>file layout</titleabbrev>
   <para>
    eINIT configuration files look like this:
   </para>
   <synopsis label="sample XML-configuration file">
    &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
    &lt;einit&gt;
     &lt;!-- [...] --&gt;

     &lt;decimal-integer-variable i="10" /&gt;
     &lt;octal-integer-variable oi="8" /&gt;
     &lt;binary-integer-variable bi="8" /&gt;
     &lt;string-variable s="string" /&gt;
     &lt;mixed-type-variable s="string" i="10" /&gt;
     &lt;boolean-true-variable b="enabled" /&gt;
     &lt;boolean-false-variable b="false" /&gt;

     &lt;!-- [...] --&gt;

     &lt;mode id="default" base="boot"&gt;
      &lt;enable mod="module1:module2:module3" /&gt;
      &lt;variable1 s="contents" /&gt;
     &lt;/mode&gt;
    &lt;/einit&gt;
   </synopsis>
   <para>
    if we examine this fictional snippet, we can observe the following:
    <itemizedlist>
     <listitem>
      <para>eINIT configuration files are regular, free-form XML files. They need to be syntactically correct (don't forget the / in elements! For example <varname>&lt;decimal-integer-variable /&gt;</varname> instead of <varname>&lt;decimal-integer-variable&gt;</varname>) and should be written in UTF-8.</para>
     </listitem>
     <listitem><para>Most elements define variables.</para></listitem>
     <listitem><para>The only (inner) element that contains elements is the <varname>&lt;mode /&gt;</varname>-element.</para></listitem>
     <listitem><para>Values are assigned to elements using attributes, i.e. <varname>&lt;variable s="string" /&gt;</varname> as opposed to <varname>&lt;variable&gt;string&lt;/variable&gt;</varname>. This is different from most other programs that use XML files for configuration, but I find this way to be more logical and intuitive.</para></listitem>
     <listitem><para>The type of a value is determined by the attribute that is used: The attribute <varname>i=""</varname> specifies an decimal integer value, <varname>s=""</varname> a string, <varname>bi=""</varname> a binary integer, <varname>oi=""</varname> an octal integer and <varname>b=""</varname> specifies a boolean flag (the values "true", "enabled" and "yes" mean the flag is on, everything else means the flag is off).</para></listitem>
     <listitem><para>A variable can have more than one type of value: it can be a string, a boolean and an integer at the same time. Which of the values is used is up to the using module to decide.</para></listitem>
     <listitem><para>A "set" of strings is always a string of the form "element1:element2", i.e. a string where the elements are delimited using a colon (':').</para></listitem>
    </itemizedlist>
   </para>
   <sect2 id="configuration-generic-special">
    <title>Special Variables</title>
    <titleabbrev>special variables</titleabbrev>
    <para>Some variables have a special meaning to eINIT's core:</para>
    <synopsis label="sample XML-configuration file">
     &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
     &lt;einit&gt;
      &lt;!-- [...] --&gt;

      &lt;module-path s="/lib/einit" /&gt;
      &lt;configuration-path s="/etc/einit/" /&gt;

      &lt;include s="file-to-include.xml" /&gt;

      &lt;!-- [...] --&gt;
     &lt;/einit&gt;
    </synopsis>
    <variablelist><title>Special Variables</title>
     <varlistentry>
      <term><varname>module-path</varname> [STRING]</term>
      <listitem>
       <para>
        The default path for ".so-modules" (i.e. those loaded using the dynamic linker). This variable is mandatory, and you should not mess with it unless you know what you're doing.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>configuration-path</varname> [STRING]</term>
      <listitem>
       <para>
        The base path for configuration files. Also mandatory, and you shouldn't mess with the default.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><varname>include</varname> [STRING]</term>
      <listitem>
       <para>
        This is used to include other configuration files. The specified string is a filename relative to the <varname>configuration-path</varname>. Use this to split the configuration into smaller parts for easier handling (see above for the default files).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>
   <sect2 id="configuration-generic-modes">
    <title>Mode configuration</title>
    <titleabbrev>modes</titleabbrev>
    <para>As has been mentioned, modes are the only elements with subelements. Consider this configuration sample:</para>
    <synopsis label="sample XML-configuration file">
     &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
     &lt;einit&gt;
      &lt;!-- [...] --&gt;

      &lt;variable1 s="x" /&gt;

      &lt;mode id="boot"&gt;
       &lt;enable mod="module4:module6" /&gt;
      &lt;/mode&gt;

      &lt;mode id="default" base="boot"&gt;
       &lt;enable mod="module1:module2:module3" /&gt;
       &lt;disable mod="module4:module5" /&gt;
       &lt;reset mod="module6" /&gt;
       &lt;variable1 s="not x" /&gt;
      &lt;/mode&gt;

      &lt;!-- [...] --&gt;
     &lt;/einit&gt;
    </synopsis>
    <para>This sample defined the modes "default" and "boot", where "default" depends on "boot". This means that default can be considered an "extension" of boot: boot is a complete mode that can be enabled and handled like all other modes, and so is default. However, if you tell einit to switch to the mode "default", then it will do all the regular dependeny calculations but it will also include the <varname>enable</varname>, <varname>disable</varname> and <varname>reset</varname> statements in the boot-mode, as if they had been specified in the default mode.</para>
    <para>Something else that should be noted: notice the element <varname>variable1</varname> in the definition of the mode "default"? This demonstrates how you can have variables that are "global" and how you can have them overriden in modes: Whenever eINIT searches for a variable, it first searches in the mode that is currently enabled (or the one that is to be enabled), then it looks for variables that are not attached to any mode. This means: in our example if you switched to mode "default" and a module requested the variable "variable1", then it would get the string "not x". If you switched to mode "boot", then "variable1" would be the string "x".</para>
    <variablelist><title>Attributes in Mode-Definitions</title>
     <varlistentry>
      <term>Element <varname>mode</varname>, Attribute <varname>id</varname> [STRING]</term>
      <listitem>
       <para>
        The name of this mode.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Element <varname>mode</varname>, Attribute <varname>base</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        IDs of other modes that this mode is based upon (see above for an explanation).
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <variablelist><title>Elements and Attributes in Modes</title>
     <varlistentry>
      <term>Element <varname>enable</varname>, Attribute <varname>mod</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        A colon-separated set of service names that should be enabled if einit is instructed to switch to this mode.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Element <varname>disable</varname>, Attribute <varname>mod</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        A colon-separated set of service names that should be disabled if einit is instructed to switch to this mode.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Element <varname>reset</varname>, Attribute <varname>mod</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        A colon-separated set of service names that should be reset if einit is instructed to switch to this mode.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>
   <sect2 id="configuration-generic-services">
    <title>Special Service-Variables</title>
    <titleabbrev>special service-variables</titleabbrev>
    <synopsis label="sample XML-configuration file">
     &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
     &lt;einit&gt;
      &lt;!-- [...] --&gt;

      &lt;!-- preferring modules --&gt;
      &lt;prefer-servicename1 s="module1:module2:module3:module4" /&gt;
      &lt;prefer-servicename2 s="module5" /&gt;

      &lt;prefer-xdm s="daemon-gdm:daemon-entrance" /&gt;

      &lt;!-- service groups --&gt;
      &lt;network group="net-lo:net-eth0" seq="most" /&gt;
      &lt;video group="kern-nvidia" seq="any-iop" /&gt;

      &lt;!-- [...] --&gt;
     &lt;/einit&gt;
    </synopsis>
    <formalpara>
     <title>Preferring modules</title>
     <para>
      Suppose you have three modules that provide the service "xdm": daemon-gdm, daemon-kdm, daemon-entrance. If you requested the service "xdm" to be enabled (for example in a mode-switch, or using the erc command), you would get these three modules, but the order in which these three modules would be tried is unspecified. Using the prefer-xdm element in this example, we tell einit to re-order these modules, so that daemon-gdm is the first to be tried, daemon-entrance is the second, and anything else (daemon-kdm in our example) is tried after that.
      <note>
       <para>
        These sections only apply to any modules found using that exact service name: if you requested a service named "x11" and daemon-kdm and daemon-gdm would also provide this service, then the service-xdm variable would not affect the order that these two modules would be tried in.
       </para>
      </note>
      <variablelist><title>Module Preferences: Elements</title>
       <varlistentry>
        <term><varname>prefer-&lt;service&gt;</varname> [STRING] [SET]</term>
        <listitem>
         <para>
          A colon-separated set of module-ids. Replace &lt;service&gt; with the service name for which you want to specify certain modules to prefer.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </formalpara>
    <formalpara>
     <title>Service groups</title>
     <para>
      The <varname>network</varname> and <varname>video</varname> elements in the example above both define service groups; Service groups are defined by creating an element with the name of the service to be defined and by adding the attribute <varname>group=""</varname> to this service that contains a set of service-names that form this abstract service. For example the <varname>network</varname>-service defined above consists of the services <varname>net-lo</varname> and <varname>net-eth0</varname>. The <varname>seq=""</varname> attribute is used to tell eINIT how many of the services need to be up to for the group to be considered "enabled".
      <note>
       <para>
        If you have a service group and a module that both provide the same service, then the module "wins". This approach was taken in order to allow for specialised modules that can take the role of a service group.
       </para>
      </note>
      <variablelist><title>Service-Groups-Variables: Attributes</title>
       <varlistentry>
        <term>Attribute <varname>group</varname> [STRING] [SET]</term>
        <listitem>
         <para>
          A colon-separated set of service ids that form this group.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>Attribute <varname>seq</varname> [STRING] ( any | any-iop | most | all )</term>
        <listitem>
         <para>
          The type of this group. <quote>any</quote> means that the service will be up if any module is up, <quote>any-iop</quote> is basically the same, but it indicates that the services are in order of preference. <quote>most</quote> tells einit to first get up as many of the listed services as possible and then to consider the group as enabled and finally <quote>all</quote> requires all services to be enabled.
          <warning>
           <para>
            The types <quote>most</quote> and <quote>all</quote> are not fully implemented, yet.
           </para>
          </warning>
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </para>
    </formalpara>
   </sect2>
  </sect1>

  <sect1 id="configuration-modules">
   <title>Default Modules</title>
   <titleabbrev>default modules</titleabbrev>
   <para>
    When I mentioned that eINIT was heavily modular, I was *not* kidding: almost all services that eINIT provides are actually provided by modules, including TTY initialisation, shell-command exection and daemon-supervision.
   </para>
   <para>
    Most of these modules use special configuration elements that are parsed by them, this section should help you find out what configuration elements there are and which modules use them.
   </para>
   <sect2 id="configuration-modules-einit-tty">
    <title>[einit-tty] Specifying TTYs</title>
    <para>
     The "einit-tty" module is used to initialise terminals. Unlike sysv-init, your terminals will be brought up ASAP, which means they're usually up after the critical filesystems are mounted.
    </para>
    <synopsis label="sample XML-configuration file">
     &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
     &lt;einit&gt;
      &lt;!-- [...] --&gt;
      &lt;!-- tty initialisation --&gt;
      &lt;tty1-regular dev="/dev/tty1" command="/sbin/agetty 38400 tty1" restart="yes" TERM="linux" /&gt;
      &lt;tty2-regular dev="/dev/tty2" command="/sbin/agetty 38400 tty2" restart="yes" TERM="linux" /&gt;
      &lt;!-- [...] --&gt;

      &lt;mode id="default" base="boot"&gt;
       &lt;enable mod="tty" /&gt;
       &lt;ttys s="tty1-regular:tty2-regular" /&gt;
      &lt;/mode&gt;
     &lt;/einit&gt;
    </synopsis>
    <para>In this example configuration file, we initialise two terminals <varname>tty1-regular</varname> and <varname>tty2-regular</varname>. This is ensured by the &lt;enable /&gt;-tag inside the &lt;mode /&gt;-tag with id="default". The &lt;enable /&gt;-tag contains a mod="tty" attribute that tells eINIT to load a tty-module upon entering this mode. Then the &lt;ttys /&gt;-tag in the &lt;mode /&gt;-tag tells einit-tty (or any other tty-module, should there be another one with a higher preference) to enable the ttys tty1-regular and tty2-regular (you can put an arbitrarily long list of colon-separated tty-names inside the s="" attribute of this tag).</para>
    <para><varname>tty1-regular</varname> is defined as
     <synopsis>      &lt;tty1-regular dev="/dev/tty1" command="/sbin/agetty 38400 tty1" restart="yes" /&gt;</synopsis>
     The tag-name is the name that is mentioned in the ttys-tag. You can choose whatever you wish here, including colourful swearing for all I care, the only constraints imposed on this is that it's a valid xml-tag-name and that it doesn't include a colon, for obvious reasons. The attribute
     <synopsis>dev="/dev/tty1"</synopsis> doesn't do anything yet, but it's reserved to be used as a device identifier. You may omit this for now, albeit that would mean to risk breaking your configuration later.
     <synopsis>command="/sbin/agetty 3800 tty1"</synopsis> This attribute tells einit-tty what command to run to get the specified tty up and running. The agetty-command in this example is intended for linux users, as most linux distributions will include agetty.
     <synopsis>restart="yes"</synopsis> Whether to restart the specified getty-command, should it die. The default is not to restart a dead tty, so you will want to specify this option.
    </para>
    <variablelist><title>Service Names and used Variables</title>
     <varlistentry>
      <term>Service <varname>tty</varname></term>
      <listitem>
       <para>
        Enable this service to enable ttys, disable to kill all ttys, reset to kill all those ttys that are enabled but should not be enabled in this mode and enable those that aren't enabled yet.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Variable <varname>ttys</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        A colon-separated set of strings specifying tty-definition variables.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <variablelist><title>TTY-Variable Attributes</title>
     <varlistentry>
      <term>Attribute <varname>dev</varname> [STRING]</term>
      <listitem>
       <para>
        Path to a tty device-file. (This is currently ignored)
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Attribute <varname>command</varname> [STRING]</term>
      <listitem>
       <para>
        The command to run for the tty to get up. (i.e. the getty binary with parametres)
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Attribute <varname>restart</varname> [BOOLEAN]</term>
      <listitem>
       <para>
        Whether or not to restart the TTY if it dies.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>All remaining Attributes</term>
      <listitem>
       <para>
        These attributes are added to the command's environment as variable=value pairs upon execution.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect2>
   <sect2 id="configuration-modules-einit-mod">
    <title>Creating Script-Modules and Daemoni</title>
    <para>
     These two types of modules are very closely related. They both execute arbitrary commands, thus allowing you to create modules by specifying the commands that need to be run to form these modules. The "shell-type" modules do exactly and only that: they execute commands to provide services. The "daemon-type" modules are similar, they however try to make sure that whatever program is executed by them will actually stay running.
    </para>

    <sect3 id="configuration-modules-einit-mod-exec">
     <title>[einit-mod-exec] simple Shell-Modules</title>
     <para>
      This module is used to create pseudo-modules that execute arbitrary shell-commands.
     </para>
     <synopsis label="sample XML-configuration file">
      &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
      &lt;einit&gt;
       &lt;!-- [...] --&gt;
       &lt;mod-shell id="shell-mount" name="Filesystems" provides="localmount" requires="sysconf"
        enable="mount -a" disable="umount -ar; mount / -o remount,ro" /&gt;
       &lt;!-- [...] --&gt;

       &lt;mode id="boot"&gt;
        &lt;enable mod="localmount" /&gt;
       &lt;/mode&gt;
      &lt;/einit&gt;
     </synopsis>
     <para>In this excerpt from the default configuration file, we see the definition of a module called "shell-mount", that goes by the name of "Filesystems". It provides a module for the "localmount"-requirement, which is required in our exemplary "boot"-mode. Additionally, it requires a "sysconf"-module to be enabled before it. The attributes <varname>enable=</varname> and <varname>disable=</varname> specify what commands to run upon enabling or disabling this pseudo-module.</para>
     <variablelist><title>Elements used to specify shell-type modules</title>
      <varlistentry>
       <term>Element <varname>mod-shell</varname> [COMPLEX VARIABLE]</term>
       <listitem>
        <para>
         Used to specify shell-type modules.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <variablelist><title><varname>mod-shell</varname> Attributes</title>
      <varlistentry>
       <term>Attribute <varname>id</varname> [STRING]</term>
       <listitem>
        <para>
         The ID of the module. This would, for example, be used in module-preferences.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>name</varname> [STRING]</term>
       <listitem>
        <para>
         The module's name. This is used by visualisers, etc.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>provides</varname> [STRING] [SET]</term>
       <listitem>
        <para>
         A colon-separated set of strings; specifies services that this module provides.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>requires</varname> [STRING] [SET]</term>
       <listitem>
        <para>
         A colon-separated set of strings; specifies services that this module requires.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>notwith</varname> [STRING] [SET]</term>
       <listitem>
        <para>
         A colon-separated set of strings; specifies the modules this module is known not to work with.
        </para>
        <note><para>Not implemented</para></note>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>enable</varname> [STRING]</term>
       <listitem>
        <para>
         The command to be run to enable the module. This is passed to /bin/sh -c (usually).
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>disable</varname> [STRING]</term>
       <listitem>
        <para>
         The command to be run to disable the module. This is passed to /bin/sh -c (usually).
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>reset</varname> [STRING]</term>
       <listitem>
        <para>
         The command to be run to reset the module. This is passed to /bin/sh -c (usually).
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>reload</varname> [STRING]</term>
       <listitem>
        <para>
         The command to be run to re-load the module. This is passed to /bin/sh -c (usually).
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>variables</varname> [STRING] [SET]</term>
       <listitem>
        <para>
 		A colon-separated set of (string-)variables that will be "imported" into the called shell upon status-changes as environment variables.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>All other attributes</term>
       <listitem>
        <para>
         All other attributes are saved as environment variables that are passed to the commands executed on behalf of this definition.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </sect3>
    <sect3 id="usage-modules-einit-mod-daemon">
     <title>[einit-mod-daemon] Daemoni</title>
     <para>
      One of the things I criticised about sysvinit was that there was no way to ensure that a daemon keeps running with only shell-scripts. This module provides exactly this functionality: You can have a special pseudo-module created that only loads a daemon, and that will resurrect this daemon if it dies.
     </para>
     <synopsis label="sample XML-configuration file">
      &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
      &lt;einit&gt;
       &lt;!-- [...] --&gt;
       &lt;mod-daemon id="daemon-gpm" name="GPM" provides="gpm" requires="sysconf:tty"
        command="/usr/sbin/gpm" restart="yes" /&gt;
       &lt;!-- [...] --&gt;

       &lt;mode id="default" base="boot"&gt;
        &lt;enable mod="gpm" /&gt;
       &lt;/mode&gt;
      &lt;/einit&gt;
     </synopsis>
     <para>The mod-daemon-tag is very similar to the mod-shell tag. In this example we see that requires="" and provides="" is actually interpreted as a colon-separated list; this is also true for the mod-shell tag. Instead of the enable="" and disable="" attributes, we have one command="" attribute that is used to specify a command that needs to be run to get this daemon up. Also this tag sports a special restart="" attribute, that tells einit-mod-daemon whether to resurrect a dead daemon or not.</para>
     <variablelist><title>Elements used to specify daemon-type modules</title>
      <varlistentry>
       <term>Element <varname>mod-daemon</varname> [COMPLEX VARIABLE]</term>
       <listitem>
        <para>
         Used to specify daemon-type modules.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <variablelist><title><varname>mod-daemon</varname> Attributes</title>
      <varlistentry>
       <term>Attribute <varname>id</varname> [STRING]</term>
       <listitem>
        <para>
         The ID of the module. This would, for example, be used in module-preferences.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>name</varname> [STRING]</term>
       <listitem>
        <para>
         The module's name. This is used by visualisers, etc.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>provides</varname> [STRING] [SET]</term>
       <listitem>
        <para>
         A colon-separated set of strings; specifies services that this module provides.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>requires</varname> [STRING] [SET]</term>
       <listitem>
        <para>
         A colon-separated set of strings; specifies services that this module requires.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>notwith</varname> [STRING] [SET]</term>
       <listitem>
        <para>
         A colon-separated set of strings; specifies the modules this module is known not to work with.
        </para>
        <note><para>Not implemented</para></note>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>command</varname> [STRING]</term>
       <listitem>
        <para>
         The command to be run to enable the module. This is passed to /bin/sh -c (usually). The module will be considered enabled as long as this command keeps running.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>prepare</varname> [STRING]</term>
       <listitem>
        <para>
         The command to be run before the daemon is executed.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>cleanup</varname> [STRING]</term>
       <listitem>
        <para>
         The command to be run after the daemon finishes executing.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>restart</varname> [BOOLEAN] (yes|no)</term>
       <listitem>
        <para>
         Whether or not to restart the daemon in case it dies. The default is not to restart the daemon, so you will want to specify this.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>Attribute <varname>variables</varname> [STRING] [SET]</term>
       <listitem>
        <para>
 		A colon-separated set of (string-)variables that will be "imported" into the called shell upon status-changes as environment variables.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>All other attributes</term>
       <listitem>
        <para>
         All other attributes are saved as environment variables that are passed to the commands executed on behalf of this definition.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
    </sect3>
   </sect2>
   <sect2 id="usage-modules-einit-feedback-textual">
    <title>[einit-feedback-textual] Status Feedback</title>
    <para>
     This is the default feedback-module. It comments on certain events, like modules being enabled or disabled; verbose output from the modules is also put on-screen. Developers could use the source file of this module to create other, more complex feedback modules.
    </para>
   </sect2>
   <sect2 id="usage-modules-mount">
    <title>[*mount] Mounting Filesystems</title>
    <para>
     The module "common-mount.so" (and "linux-mount.so" on linux) are used to mount and unmount filesystems. They use a rather large number of variables, and you will most likely need to modify at least one of them.
    </para>
    <synopsis label="sample XML-configuration file">
     &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
     &lt;einit&gt;
      &lt;!-- [...] --&gt;

      &lt;mount-update-steps s="block-devices:metadata" /&gt;
      &lt;mount-fstab-source s="label:configuration" /&gt;
      &lt;mount-mtab-source s="legacy" /&gt;
      &lt;mount-block-devices-source s="dev" /&gt;
      &lt;mount-filesystem-label-readers s="linux" /&gt;
      &lt;mount-critical s="/usr:/var" /&gt;
      &lt;mount-fsck-command s="/sbin/fsck -a -T -t %s %s" /&gt;

      &lt;!-- [...] --&gt;

      &lt;fstab-entry mountpoint="/dev" fs="tmpfs" after-mount="/sbin/udevstart" manager="/sbin/udevd" /&gt;
      &lt;fstab-entry mountpoint="/sys" fs="sysfs" /&gt;

      &lt;!-- [...] --&gt;
     &lt;/einit&gt;
    </synopsis>
    <variablelist><title>Service Names</title>
     <varlistentry>
      <term>Service <varname>mount/root</varname></term>
      <listitem>
       <para>
        (Re-)Mount the root-filesystem (RW).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Service <varname>mount/system</varname></term>
      <listitem>
       <para>
        Mount important system-specific mountpoints (e.g. /dev, /proc and /sys on linux).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Service <varname>mount/critical</varname></term>
      <listitem>
       <para>
        Mount "critical" filesystems. "Critical filesystems" are those that are needed for your system to function beyond putting cryptic messages on your screen, i.e. "/usr" and "/var" would be critical filesystems. There is more than one way to specify what filesystems are critical, see below.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Service <varname>mount/local</varname></term>
      <listitem>
       <para>
        Mount all the other local filesystems. Things like /home and /media/*.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Service <varname>mount/remote</varname></term>
      <listitem>
       <para>
        Mount all the other remote filesystems. Things like your nfs directories.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <note>
     <para>
      Even though it is considered good practice by lots of *nix zealots, it is not necessary to have all these filesystems on their own partitions or harddisks. If there are no fstab-entries for some of these, then they are silently skipped. You could think of these services as "availability levels": in your modules, simply make sure to specify the right "level". If in doubt, you'll most likely need "mount/critical".
     </para>
    </note>
    <variablelist><title>Variables (excerpt)</title>
     <varlistentry>
      <term>Variable <varname>mount-update-steps</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        A colon-separated set of strings specifying all the optional update steps for the *mount modules. If this is not specified, then all update steps will be performed, if this is specified, then everything will be done, except for metadata reading and block-device scans, see below for more information.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Variable <varname>mount-fstab-source</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        A colon-separated set of strings specifying all the fstab sources the *mount modules should use. See <xref linkend="usage-modules-mount-fstab" /> for a list of all the available options and which of them does what.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Variable <varname>mount-mtab-source</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        A colon-separated set of strings specifying all the mtab sources the *mount modules should use. Currently there's only the option "legacy", so you better just leave it like that.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Variable <varname>mount-block-devices-source</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        Sources for the in-memory block-device list. This list is used by the metadata scanner, and could be used by some of the mount-functions. "dev" is a good choice here, but see below for a complete explanation.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Variable <varname>mount-filesystem-label-readers</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        What filesystem metadata readers to use. "linux" currently reads metadata from ext2/3 and reiserfs filesystems, but it's only available on linux (or rather, if linux-mount.so is loaded).
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Variable <varname>mount-critical</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        Define which filesystems are considered "critical", see below for a full explanation.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Variable <varname>mount-fsck-command</varname> [STRING] [SET]</term>
      <listitem>
       <para>
        Define a template for the fsck command to be used on unclean filesystems. This is passed to printf, the first %s is replaced by the filesystem type, the second %s is replaced by the block device node.
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Variable <varname>fstab-entry</varname> [COMPLEX VARIABLE]</term>
      <listitem>
       <para>
        Define a mountpoint and what to mount there, see below for a full explanation of how this works.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>

    <sect3 id="usage-modules-mount-fstab">
     <title>FSTab sources</title>
     <synopsis label="relevant elements from sample XML-configuration file">
      &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
      &lt;einit&gt;
       &lt;!-- [...] --&gt;

       &lt;mount-fstab-source s="label:configuration" /&gt;

       &lt;!-- [...] --&gt;

       &lt;fstab-entry mountpoint="/dev" fs="tmpfs" after-mount="/sbin/udevstart" manager="/sbin/udevd" /&gt;
       &lt;fstab-entry mountpoint="/sys" fs="sysfs" /&gt;

       &lt;!-- [...] --&gt;
      &lt;/einit&gt;
     </synopsis>
     <para>
      eINIT can use more than one "source" for FSTab entries. The number of sources is theoretically unlimited, but right now we only have three of them:
     </para>
     <variablelist><title>Elements used to specify FSTab Sources</title>
      <varlistentry>
       <term>Variable <varname>mount-fstab-source</varname> [STRING] [SET]</term>
       <listitem>
        <para>
         A colon-separated set of strings specifying all the fstab sources the *mount modules should use. See the following list for strings thar might be in this set.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>
     <variablelist><title>Currently implemented FSTab Sources</title>
      <varlistentry>
       <term><varname>legacy</varname></term>
       <listitem>
        <para>
         Legacy fstab (/etc/fstab), see <xref linkend="usage-modules-mount-fstab-legacy">.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><varname>configuration</varname></term>
       <listitem>
        <para>
         FSTab entries in your configuration file (&lt;fstab-entry /&gt;-nodes), see <xref linkend="usage-modules-mount-fstab-configuration">.
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term><varname>label</varname></term>
       <listitem>
        <para>
         This will make eINIT <quote>guess</quote> filesystem mount points by their labels, see <xref linkend="usage-modules-mount-fstab-label">.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <sect4 id="usage-modules-mount-fstab-legacy">
      <title>Legacy FSTab (/etc/fstab)</title>
      <para>
       Like most other related *nix tools, eINIT can use your /etc/fstab file. If you need to find out what this file is supposed to look like, see your unix man pages, the node is usually called "fstab" or "mount".
      </para>
      <note>
       <para>
        These "legacy" fstab entries are less flexible than their configuration-file equivalents, thus you should rather use those, if possible. If you're just testing eINIT, you could probably use this, if not, you should use the configuration entries.
       </para>
      </note>
     </sect4>

     <sect4 id="usage-modules-mount-fstab-configuration">
      <title>Configuration-Fstab-Entries</title>
      <synopsis label="relevant elements from sample XML-configuration file">
       &lt;?xml version="1.0" encoding="UTF-8" ?&gt;
       &lt;einit&gt;
        &lt;!-- [...] --&gt;

        &lt;fstab-entry mountpoint="/dev" fs="tmpfs" after-mount="/sbin/udevstart" manager="/sbin/udevd" /&gt;

        &lt;!-- [...] --&gt;
       &lt;/einit&gt;
      </synopsis>
      <para>
       FSTab-entries can be specified inside your configuration file (a good place would be rc.xml) using the element <varname>&lt;fstab-entry /&gt;</varname>. This is the most flexible way to specify mountpoints, because you can (optionally) combine the mounting action with commands to run.
      </para>
      <warning>
       <para>
        Never disable this fstab-source, unless you want /dev, /proc, /sys, /dev/pts and similar to break! Also, don't remove the configuration file entries for these mountpoints, or things will go haywire in the same way! You have been warned!
       </para>
      </warning>
      <variablelist><title>Attributes of the fstab-entry Element</title>
       <varlistentry>
        <term>Attribute <varname>mountpoint</varname> [STRING]</term>
        <listitem>
         <para>
          The mountpoint where this filesystem should be mounted. You always have to specify this.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>Attribute <varname>device</varname> [STRING]</term>
        <listitem>
         <para>
          What to mount there. Usually a block-device, but could be of the form <filename>host:/path/to/directory</filename> for remote filesystems.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>Attribute <varname>fs</varname> [STRING]</term>
        <listitem>
         <para>
          The filesystem name to pass to the kernel (ufs, ext2, ext3, reiserfs, ...).
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>Attribute <varname>encryption</varname> [STRING]</term>
        <listitem>
         <para>
          What encryption algorithm to use...
         </para>
         <note><para> - NOT IMPLEMENTED - </para></note>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>Attribute <varname>options</varname> [STRING] [SET]</term>
        <listitem>
         <para>
          Filesystem options (noatime, rw, ro, ...). See your filesystem's manual for a complete list of allowed options. Note that this set uses the colon (:) as a delimiter (!), not the comma that you would normally find in your /etc/fstab.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>Attribute <varname>before-mount</varname> [STRING]</term>
        <listitem>
         <para>
          A command to run before the filesystem is mounted, possibly to prepare the filesystem for being mounted.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>Attribute <varname>after-mount</varname> [STRING]</term>
        <listitem>
         <para>
          A command to run after the filesystem is mounted.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>Attribute <varname>manager</varname> [STRING]</term>
        <listitem>
         <para>
          A daemon that will be started after the filesystem is mounted, and after the "after-mount" command was executed (if any). This is, for example, used to bring up udevd after /dev has been mounted on newer linux kernels.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>Attribute <varname>before-umount</varname> [STRING]</term>
        <listitem>
         <para>
          A command to run before the filesystem is unmounted.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>Attribute <varname>after-umount</varname> [STRING]</term>
        <listitem>
         <para>
          A command to run after the filesystem is unmounted, or if it failed to mount at all.
         </para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>Attribute <varname>variables</varname> [STRING] [SET]</term>
        <listitem>
         <para>
          You can specify a set of (configuration-)variables to be passed to the command as environment variables using this attribute.
         </para>
        </listitem>
       </varlistentry>
      </variablelist>
     </sect4>

     <sect4 id="usage-modules-mount-fstab-label">
      <title>FSTab-from-label-forger</title>
      <para>
       This is a somewhat new idea: Instead of specifying an fstab yourself, you can use filesystem labels and have eINIT *guess* the mountpoint of the filesystems by these labels.
      </para>
      <para>
       The approach eINIT takes to guessing looks somewhat like this:
      </para>
      <itemizedlist>
       <listitem><para>Are there slashes (/) in the label? If so, use the label as the mountpoint.</para></listitem>
       <listitem><para>Are there dashes (-) in the label <emphasis>and</emphasis> does the label start with the hostname, followed by a dash? If so, convert a label of the form <quote>hostname-path-to-mountpoint</quote> to <quote>/path/to/mountpoint</quote> if the hostname in the label is the same as the current hostname. (exception: <quote>hostname-root</quote> becomes <quote>/</quote>)</para></listitem>
       <listitem><para>Else, dashes or not, mount the filesystem as <quote>/media/&lt;label&gt;</quote></para></listitem>
      </itemizedlist>
      <note>
       <para>
        This label reader has apparently caused some havoc in the past, so it is now disabled by default. The main problem was that it could cause filesystems to be mounted twice if the filesystem has another source specify a mountpoint and the label is in a format that eINIT can base no guesses on, and thus an fsck could be run on an already mounted filesystem. Then fsck would complain and expect user input, which was impossible, and then the modeswitch got stuck.
       </para>
      </note>
     </sect4>

    </sect3>
   </sect2>
  </sect1>
 </chapter>

 <chapter id="usage">
  <title>Usage</title>
  <sect1 id="usage-einit-control">
   <title>Interfacing with eINIT: einit-control</title>
   <titleabbrev>einit-control</titleabbrev>
   <synopsis>einit-control [-h]</synopsis>
   <synopsis>einit-control [-s control-socket] [function] command</synopsis>
   <para>
    This is the main command to control eINIT: it connects to socket <varname>control-socket</varname> and submits <varname>function</varname> and <varname>command</varname> for eINIT to interpret.
   </para>
   <note><para>The "power", "erc" and "rc" commands are usually (sym-)linked to the einit-control binary. For example, calling <userinput>einit-control power off</userinput> is the same as calling <userinput>power off</userinput>, if the proper links are in place.</para></note>
   <sect2 id="usage-einit-control-power">
    <title>The "power"-command</title>
    <titleabbrev>power</titleabbrev>
    <synopsis>power [-h]</synopsis>
    <synopsis>power [-s control-socket] command</synopsis>
    <synopsis>einit-control [-s control-socket] power command</synopsis>
    <para>
     This command is used to tell eINIT that you wish to shut down or reboot your computer. The <varname>command</varname> must bei either of <userinput>off</userinput> or <userinput>reset</userinput>, which will tell eINIT to power off or reset, respectively.
    </para>
   </sect2>
   <sect2 id="usage-einit-control-erc">
    <title>The "erc" and "rc"-commands</title>
    <titleabbrev>erc</titleabbrev>
    <synopsis>[e]rc [-h]</synopsis>
    <synopsis>[e]rc [-s control-socket] command</synopsis>
    <synopsis>einit-control [-s control-socket] rc command</synopsis>
    <para>
     This command is used to tell eINIT that you wish to change modes or enable/disable a module.
    </para>
    <synopsis>[e]rc [-s control-socket] switch-mode mode</synopsis>
    <para>
     Make eINIT switch to the specified <varname>mode</varname>
    </para>
    <synopsis>[e]rc [-s control-socket] module (enable|disable)</synopsis>
    <para>
     Make eINIT enable or disable the specified <varname>module</varname>.
    </para>
    <note><para>Whether the command is/should be named rc or erc depends on the environment: if you only set up a test-environment, you would want the command to be called "erc", because sysvinit usually depends on an /sbin/rc command to do some of the dirty work.</para></note>
   </sect2>
  </sect1>
 </chapter>

 <appendix id="concepts">
  <title>Concepts</title>
  <para>Since we're trying to be revolutionary, we're bound to do some things differently, aren't we?</para>
  <sect1 id="concepts-modes">
   <title>Modes</title>
   <titleabbrev>modes</titleabbrev>
   <para>
    A <quote>mode</quote> is a set of modules and settings for said modules that belong together to form a sort of "usage profile" for your Unix-machine. Modes are related to sysvinit's runlevels, except that they not only contain a set of processes that need to be run to form a runlevel, but that eINIT supports configuration entries to be associated with modes. Also eINIT is not limited to 6/7 runlevels (level 1 through 6 and S, with the mentioned three
    already having a special meaning), but it allows for an arbitrary number of named modes, each of which can depend on a set of other modes.
   </para>
   <para>
    Okay, this is admittedly a tad abstract, so let's try to make this a bit more clear. As has been mentioned, modes can form a sort of usage-profile for your computer. Thus you could have one mode for "server", one for "workstation". Now, when you think about it, both require the same set of basic initialisation: mounting filesystems, setting up hardware, monitoring hardware events... and doing all these things alone would probably be sufficient for a single-user session, so we make this a new mode and call it "boot". Now we have three modes: boot, server and workstation, with server and workstation both depending on boot. That means you can put all the common modules into boot and concentrate on which services you wish to start in the server mode (network, firewall, apache, mysql) and which to start in the workstation mode (X11, e17...). Now, when eINIT boots (or switches modes) to either of "server" or "workstation", it will take all the entries in "boot" into consideration as well and it will make sure that everything is loaded with a minimum of changes to whatever is running right now, doing as much as possible in parallel.
   </para>
   <para>
    And when you think about this a little harder, the server mode is just an extended "firewall" or "router"-mode... you get the drift :D
   </para>
  </sect1>
  <sect1 id="concepts-services">
   <title>Services</title>
   <titleabbrev>services</titleabbrev>
   <para> -- write me! -- </para>
   <sect2 id="concepts-services-groups">
    <title>Service Groups</title>
    <titleabbrev>service groups</titleabbrev>
    <para> -- write me! -- </para>
   </sect2>
  </sect1>
 </appendix>

</book>