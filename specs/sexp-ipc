zeh closer specz:

SEXPRS:
we're using sexprs for our IPC, but they're kinda trimmed down for what we need:
the only valid types are these:
 * "strings" up to 4095 characters in length
 * integers (123456) up to 31 characters in length
 * symbols up to 1023 characters in length
 * (lists of mixed contents)
 * booleans #t and #f
 * #nil

special rules:
 * "strings
may span across newlines
and have things \"escaped\" with a \\ backslash"
 * anything that starts with a hash '#' is turned into either #t, #f or #nil, depending on whether the
   first char is 't', 'f', or anything else. that means # is also #nil
 * \\ backslash-escapes only work in strings. in symbols, backslashes turn into literal characters
 * \n, \t and the like don't turn into newlines or tabs. just use literal newlines, or tabs.
 * \0 is interpreted as whitespace, but try to avoid it anyway
 * some other sexpr parsers allow omitting whitespace when one would think that things are clear enough,
   for example: ("hello"123"world") would be read as ("hello" 123 "world") by those parsers. einit's
   sexpr parser doesn't allow this tho, so don't do it.

note: you can't really depend on the order of replies as soon as events are in the game. if you dont use
events, you'll end up with something fifo-ish. if you do use events, it might turn lifo, or something
really weird, so just dont depend on the order of replies. 
 
signals: (work both ways, no replies)
------------------------------------------------------------------------
* (event type integer status task flag string stringset module)
type -> symbol
integer -> integer
status -> integer
task -> integer
flag -> integer
string -> string
stringset -> list(string)
module -> symbol
 
you get to write this at any time you feel like it.
 
 
 
requests: (should also work both ways, always require a reply)
------------------------------------------------------------------------
REQUESTS: (request type tag payload)
REPLIES: (tag payload)

the tag MUST be an integer. that integer may also be re-used for new requests, if the old one got a reply
already.
 
--- event requests:
 
* (request receive-events tag no-backlog) ; verbatim
  (tag <#t/#f>)
tell the core you want to receive events, but not have the whole log replayed
 
* (request receive-events tag backlog) ; verbatim
  (tag <#t/#f>)
tell the core you want to receive events, including everything emitted before you connected.
 
* (request receive-events tag replay-only) ; verbatim
  (tag <#t/#f>)
tell the core you want to receive events, but only olden ones, not new events. you get the reply to this
/after/ all the events have been signaled to you.
 
* (request receive-specific-events tag type)
  (tag <#t/#f>)
tell the core you want to receive events of the specified type (a symbol). multiple calls to this stack
and tell the core to give you events of multiple types. using this will not actually make the core send
you any events, it'll just flag the appropriate events for you. to start receiving the events, use one
of the three calls above. if you don't use this command, then you'll simply receive _all_ events.
 
* (request mute-specific-events tag type)
  (tag <#t/#f>)
analoguous to the last command, just flagging the specific event type as uninteresting to you.
 
--- configuration
 
* (request get-configuration-multi tag key)
  (tag ((attribute value) (attribute value) <etc>))
retrieve config data (specific key, symbol)
 
* (request get-configuration tag (key attribute))
  (tag value)
retrieve config data (specific key and attribute, both are symbols)
value is either the string that was fetched, or #f
 
* (request get-configuration* tag prefix)
  (tag ((key (attribute value) (attribute value) <etc>)) (key (attribute value) (attribute value) <etc>))))
retrieve loads of config data by means of a common prefix. prefix is a symbol
 
--- modules
 
* (request register-module tag (rid "name" (provides) (requires) (before) (after) (uses) run-once deprecated))
  (tag <#t/#f>)
register an event-based module handler. run-once and deprecated are booleans, the (provides), etc are
lists of symbols. rid is also a symbol, while name is a string
 
* (request register-module-actions tag (rid (actions))
  (tag <#t/#f>)
tell the core that the specified rid (symbol) can handle all the actions described in the list (actions) (a list of symbols)
 
* (request list tag modules)
  (tag (rid1 rid2 rid3 rid4 rid5 <etc>))
get a list of all modules. everything involved is a symbol.
 
* (request get-module tag rid)
  (tag (rid "name" (provides) (requires) (before) (after) (uses) run-once deprecated (status) (actions)))
get details on the specified rid, if possible. the specs for the list are exactly the same as for register-module; the additional (status) field is a list of symbols describing the current status of the module; the extra (actions) field lists all the actions that the module is known to be capable of.
 
--- services
 
* (request list tag services)
  (tag (service1 service2 service3 service4 <etc>))
get a list of all services. everything involved is a symbol.
 
* (request get-service tag service)
  (tag (status))
get details on the specified service, if possible. the reply is a list of symbols describing the service's status
 
--- modes
 
* (request list tag modes)
  (tag (mode1 mode2 mode3 mode4 <etc>))
get a list of all modes. everything involved is a symbol.
 
--- status changes
 
* (request module-do! tag (rid action))
  (tag <#t/#f>)
tell the core to make the module specified by rid do something. rid and action are both symbols. a reply to this doesn't mean the module is done working, it just serves as some kind of 'receipt'. figuring out how the module's progressing should be done by means of events. enable/disable actions are likely to be subject to dependencies, but with this request, dependencies are _not_ resolved automatically. if the deps aren't met, the command will just do nothing.
 
* (request service-do! tag (service action))
  (tag <#t/#f>)
analoguous to module-do!, just with a service instead of an rid. for enable/disable actions, this will also do dependency resolution, unlike module-do!.
 
* (request switch-mode tag mode)
  (tag <#t/#f>)
tell the core to switch to the mode denoted by the symbol 'mode'.
